<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xmlns="http://docbook.org/ns/docbook"
    xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:svg="http://www.w3.org/2000/svg" xmlns:m="http://www.w3.org/1998/Math/MathML"
    xmlns:html="http://www.w3.org/1999/xhtml" xml:id="extending-ironbee">
    <title>Extending IronBee</title>
    <para>...</para>
    <section>
        <title>Overview</title>
        <para>...</para>
    </section>
    <section>
        <title>Execution Flow</title>
        <section>
            <title>Definitions</title>
            <variablelist>
                <varlistentry>
                    <term>Engine</term>
                    <listitem>
                        <para>The framework that controls data flow, state and code
                            execution.</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Plugin</term>
                    <listitem>
                        <para>Server native code for embedding the engine into another software base
                            (e.g. the Apache httpd server). The plugin is responsible for
                            instantiating the engine, initiating the initial configuration process,
                            feeding the engine with data and optionally implementing methods of
                            blocking.</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Hook</term>
                    <listitem>
                        <para>A hook is an execution point within the engine that allows external
                            code to be registered and executed as if it were part of the engine.
                            There are many builtin hooks in the IronBee engine and custom hooks can
                            also be added. Hooks are typically leveraged by modules.</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Module</term>
                    <listitem>
                        <para>Engine code that is not essential to the core engine, but rather
                            extends what the engine can accomplish by hooking into it. Modules in
                            IronBee are dynamically loadable files which can extend and alter how
                            the engine executes. There are a number of different types of modules
                            which will be explained in detail. Some examples of modules are HTTP
                            parsers, matching algorithms, logging methods, rule languages/executors
                            and specialized detection techniques. All IronBee features are
                            essentially modules, which allows nearly every aspect of the engine to
                            be extended.</para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <variablelist>
                <varlistentry>
                    <term>Provider Definition</term>
                    <listitem>
                        <para>An abstract interface, optionally defining an API, which can be used
                            to extend functionality of the engine. There are a number of providers
                            defined by the core module for parsing, logging, data manipulation,
                            matching, etc. Each definition includes a unique type, which must be
                            implemented by a provider. The provider definition essentially describes
                            the methods that must be implemented to extend the engine with the given
                            type of functionality.</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Provider</term>
                    <listitem>
                        <para>Code (normally a module) implementing an abstract interface described
                            by the provider definition. This code is then registered with the
                            provider definition type and a unique key for later lookup. For example,
                            the core module defines a provider of type "matcher" which must have a
                            set of methods implemented. The "pcre" module implements these methods
                            and registers a PCRE matcher, which can then be used by other modules to
                            perform PCRE based matches.</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Provider Instance</term>
                    <listitem>
                        <para>Some providers may require multiple instances to be instantiated with
                            differing scope or configurations. A provider instance is such an
                            instantiation, which is associated with both a provider and a
                            configuration. As an example, the data provider must manage data in
                            various scopes (e.g. connection data, session data and transaction
                            data). The core module creates a provider instance handling this data
                            for each of the different scopes. Another example is the logger provider
                            which must allow the same file based logger (a provider) to be
                            configured differently per configuration context (e.g. log to different
                            log files). </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </section>
        <section>
            <title><?oxy_comment_start author="brectanus" timestamp="20110128T233116-0800" comment="This section needs to be updated as it is a bit outdated."?>Flow<?oxy_comment_end?></title>
            <para>There are four main stages of execution detailed below.</para>
            <section>
                <title>Startup Stage</title>
                <para>During startup, the plugin is instantiated by whatever server has loaded it,
                    for example when the Apache httpd server loads/configures the plugin. During
                    this stage, the plugin instantiates the engine and initiates the configuration stage.<orderedlist>
                        <listitem>
                            <para>Server starts and instantiates/starts the plugin.</para>
                        </listitem>
                        <listitem>
                            <para>Plugin is configured with native plugin configuration, which
                                includes the location of the engine configuration.</para>
                        </listitem>
                        <listitem>
                            <para>Utility libraries are initialized.</para>
                        </listitem>
                        <listitem>
                            <para>Engine is instantiated.</para>
                            <orderedlist>
                                <listitem>
                                    <para>An engine configuration context is created.</para>
                                </listitem>
                                <listitem>
                                    <para>Static core module is loaded which defines builtin
                                        provider APIs.</para>
                                </listitem>
                            </orderedlist>
                        </listitem>
                        <listitem>
                            <para>Plugin registers a native logging provider.</para>
                        </listitem>
                        <listitem>
                            <para>Engine configuration stage is initiated based on initial plugin
                                configuration.</para>
                        </listitem>
                    </orderedlist></para>
            </section>
            <section>
                <title>Configuration Stage</title>
                <para>During configuration, the configuration files/scripts are read/executed,
                    engine modules are loaded/initialized and contexts are created/configured in
                    preparation for the runtime stage. The following is an outline of what will
                    happen during this stage.</para>
                <orderedlist>
                    <listitem>
                        <para>Configuration is read/executed.</para>
                    </listitem>
                    <listitem>
                        <para>The main configuration context is created.</para>
                    </listitem>
                    <listitem>
                        <para>Modules are loaded.<orderedlist>
                                <listitem>
                                    <para>Module global configuration data is copied to the global
                                        context as a base configuration.</para>
                                </listitem>
                                <listitem>
                                    <para>Module "init" function is called just after it is loaded
                                        to initialize any global module configuration.</para>
                                </listitem>
                                <listitem>
                                    <para>Modules may hook into the engine globally by registering
                                        to be called when certain events occur.</para>
                                </listitem>
                                <listitem>
                                    <para>If successfully initialized, a module is registered with
                                        the engine.</para>
                                </listitem>
                            </orderedlist></para>
                    </listitem>
                    <listitem>
                        <para>Configuration contexts are created and registered along with a
                            function which will be executed to determine if the context will be
                            chosen at runtime.</para>
                    </listitem>
                    <listitem>
                        <para>Modules register themselves with a configuration context if they are
                            to be used in that context.</para>
                        <orderedlist>
                            <listitem>
                                <para>Module "context init" function is called to initialize any
                                    context configuration.</para>
                            </listitem>
                            <listitem>
                                <para>Modules may hook into the engine for the given context by
                                    registering to be called when certain events occur.</para>
                            </listitem>
                        </orderedlist>
                    </listitem>
                    <listitem>
                        <para>The runtime stage is initiated.</para>
                    </listitem>
                </orderedlist>
                <section>
                    <title>Runtime Stage</title>
                    <para>During runtime all of the configuration has been finalized and the engine
                        will now handle data passed to it by the plugin. Data is handled by the
                        state machine which essentially follows a four step process. First, a
                        configuration context is chosen. Second, the request is handled. Third the
                        response is handled. And finally any post processing is performed. Below is
                        an outline of the flow.</para>
                    <orderedlist>
                        <listitem>
                            <para>Raw connection HTTP data is received by the plugin and passed to
                                the engine.</para>
                        </listitem>
                        <listitem>
                            <para>[Need to add connection context here. Events could be: conn open,
                                conn data (inbound/outbound), conn close. Configuration options
                                include which protocol parser to use, default parser configuration,
                                whether to decrypt SSL, private keys for decryption, etc.]</para>
                        </listitem>
                        <listitem>
                            <para>If the connection is encrypted, SSL decryption takes place. This
                                step is optional and will largely depend on how the plugin is
                                designed. For example, the Apache plugin will always send decrypted
                                data.</para>
                        </listitem>
                        <listitem>
                            <para>The engine parses the data as a stream, buffering if configured to
                                do so.</para>
                        </listitem>
                        <listitem>
                            <para>The parser notifies the engine of various events (request headers
                                available, request body, etc.)</para>
                        </listitem>
                        <listitem>
                            <para>Any hooks associated with events are executed.</para>
                        </listitem>
                        <listitem>
                            <para>Once enough data is available, the configuration context selection
                                process is started configuration context function until one returns
                                that it wants to be enabled.</para>
                            <orderedlist>
                                <listitem>
                                    <para>At this point all modules registered in the chosen context
                                        will have their "context activated" functions executed,
                                        allowing them to be prepared for executing in the
                                        context.</para>
                                </listitem>
                            </orderedlist>
                        </listitem>
                        <listitem>
                            <para>Further events occur and associated hooks are executed, but now
                                with the chosen configuration context instead of the global
                                context.</para>
                        </listitem>
                    </orderedlist>
                </section>
                <section>
                    <title>Reconfiguration Stage</title>
                    <para>During a reconfiguration, the engine has been notified that configuration
                        changes are available and should be reloaded. This is very similar to
                        startup, except that instead of the plugin initiating the configuration
                        stage, the engine is initiating the configuration stage. During this time
                        and current data being processed will continue to use the old
                        configuration.</para>
                    <para> TODO</para>
                </section>
            </section>
        </section>
    </section>
    <section>
        <title>Hooks</title>
        <para>TODO: Add description of each hook</para>
    </section>
    <section>
        <title>Modules</title>
        <para>Modules make up the majority of executed code in IronBee.  Most features are built
            using modules.  There are three primary reasons for this. First, it makes the code more
            readable and each feature more self contained. Second, it allows only features in use to
            be loaded into the executable. And last, since moduels are shared libraries, it makes
            for easier upgrades as the engine only needs to unload the old code and reload the
            new.</para>
        <para>Modules can interact with the engine in quite a few different ways. However, there are
            two primary module types: provider and standalone. The simplest is the provider module,
            which implements one of the many predefined (or even custom) provider definitions. As an
            example, a provider module can be used to extend logging capabilities, add a different
            type of pattern matcher or provide a different way of storing/accessing data. The
            provider module typically will define a configuration and set of functions implementing
            a provider's well defined interface, then register these functions with the engine. A
            standalone module will typically be more involved. Standalone modules can hook into any
            part of the engine and typically used to implement a new detection technique or provide
            some sort of filtering. To do this, the standalone module defines a configuration and
            registers functions with various hooks in the engine. While this is similar to a
            provider module, there is no well defined set of functions to implement in a standalone
            module.</para>
        <section>
            <title>Standalone Modules</title>
            <para>Modules have three essential duties. A module must export a known symbol so that
                it can be loaded. A set of configuration parameters must be set. And common module
                functions must be registered which will be called at various initialization and
                cleanup points. With Lua, however, this is much more simplified than in C.</para>
            <para>Exporting a symbol is quite language specific and will not be discussed
                here.</para>
            <para>Any number of configuration parameters are registered with the engine and their
                storage locations are then mapped by the engine both globally to the module as well
                as into each configuration context. As of this writing, there are two types of
                configuration parameters, numeric and string. Along with configuration parameter
                definitions can be defined default values.</para>
            <para>The eventual goal of a module is to register functions to be called by the engine.
                Typically in  a standalone module, this is done by registering functions to be
                called with hooks. Hooks allow executing at defined points in the
                connection/transaction lifecycle, which is documented with the state machine in the
                API documentation.</para>
            <para>TODO: Need more on what a basic module will look like without going into language
                details.</para>
        </section>
        <section>
            <title>Provider Modules</title>
            <para>A provider module typically implements the core provider APIs -- allowing
                different methods of debug logging, buffering, etc. -- but a provider module can
                also extend the core by adding its own custom interface. Providers are defined with
                a set of module configuration parameters, an API to allow calling the provider and
                an abstract interface which must be implemented by other modules. This abstract
                interface is what most provider modules will be implementing.</para>
            <para>The provider API is the interface in which the consumer will use to provide the
                service. This is essentially the public calling interface. Typically this is already
                defined by the core provider definitions and is only used to define custom
                providers. The core logger API defines two functions to perform logging. The first
                is a vprintf like function with a va_list argument and the second a printf like
                function with a variable argument list.</para>
            <para>To implement a defined provider interface, a module needs to register any required
                interface functions with the engine with a unique key. At this point the provider's
                register function is called. This function is defined with the provider and is
                typically used to validate the registered interface, allowing version checking as
                well as any initial setup (the "version" field is defined by the default interface
                header).</para>
            <para>The provider interface is what is called by the API to do the real work. This is a
                private interface in which any module implementing this provider will need to
                implement. In the case of the logger provider, there is a single function named
                "logger" of type "qi_log_logger_fn_t". Both of the functions defined in the API will
                just call this function to do the actual logging. Note, as in this case, the public
                API does not have to match the private interface.</para>
            <section>
                <title>Core Provider Interfaces</title>
                <para>The engine core defines a number of standard provider interfaces which a
                    module can implement. Each interface is implemented using the same concepts as
                    above, however each has a different API.</para>
                <section>
                    <title>Logging Interface</title>
                    <para>...</para>
                    
                </section>
                <section>
                    <title>Event Interface</title>
                    <para>...</para>
                </section>
                <section>
                    <title>HTTP Parser Interface</title>
                    <para>...</para>
                </section>
                <section>
                    <title>Matcher Interface</title>
                    <para>...</para>
                </section>
                <section>
                    <title>Data Interface</title>
                    <para>...</para>
                </section>
                <section>
                    <title>Event Interface</title>
                    <para>...</para>
                </section>
            </section>
        </section>
    </section>
    <section>
        <title>Writing Modules in C</title>
        <para>Basic format of a module...</para>
        <para>TODO: Add back the provider module examples in C.</para>
        <programlisting>/* -- Include Standard Headers for Modules. -- */

#include &lt;ironbee/ironbee.h>
#include &lt;ironbee/util.h>
#include &lt;ironbee/module.h>


/* -- Module Data -- */

/* Define the module name as well as a string version of it. */
#define MODULE_NAME        example
#define MODULE_NAME_STR    IB_XSTRINGIFY(MODULE_NAME)

/* Declare a configuration structure. */
typedef struct ex_cfg_t ex_cfg_t;
struct ex_cfg_t {
    uint64_t       numval;                /* Number */
    char          *strval;                /* String */
};

/* Define the public module symbol. */
IB_MODULE_DECLARE();

/* Instantiate a module global configuration. */
static ex_cfg_t ex_global_cfg;


/* -- Module Routines -- */

/* Initialize module on load. */
static ib_status_t ex_init(ib_engine_t *ib)
{
    IB_FTRACE_INIT(ex_init);
    IB_FTRACE_RET_STATUS(IB_OK);
}

/* Cleanup module on unload. */
static ib_status_t ex_fini(ib_engine_t *ib)
{
    IB_FTRACE_INIT(ex_fini);
    IB_FTRACE_RET_STATUS(IB_OK);
}

/* Initialize a module when added to a context. */
static ib_status_t ex_context_init(ib_engine_t *ib,
                                   ib_context_t *ctx)
{
    IB_FTRACE_INIT(ex_context_init);
    IB_FTRACE_RET_STATUS(IB_OK);
}


/* -- Module Configuration -- */
static IB_CFGMAP_INIT_STRUCTURE(modpcre_config_map) = {
    /* example.numval */
    IB_CFGMAP_INIT_ENTRY(
        MODULE_NAME_STR ".numval",        /* Variable1 name */
        IB_FTYPE_NUM,                     /* Variable1 type */
        &amp;ex_global_cfg,                   /* Config structure addr */
        numval,                           /* Config structure name */
        5                                 /* Default value */
    ),
    /* example.strval */
    IB_CFGMAP_INIT_ENTRY(
        MODULE_NAME_STR ".strval",        /* Variable2 name */
        IB_FTYPE_NULSTR,                  /* Variable2 type */
        &amp;ex_global_cfg,                   /* Config structure addr */
        strval,                           /* Config structure name */
        "default"                         /* Default value */
    ),

    IB_CFGMAP_INIT_LAST                   /* Mark the end */
};


/* -- Module structure -- */
IB_MODULE_INIT(
    IB_MODULE_HEADER_DEFAULTS,            /* Default metadata */
    MODULE_NAME_STR,                      /* Module name */
    IB_MODULE_CONFIG(&amp;ex_global_cfg),     /* Global config data */
    ex_config_map,                        /* Configuration field map */
    ex_init,                              /* Initialize function */
    ex_fini,                              /* Finish function */
    ex_context_init,                      /* Context init function */
);</programlisting>
    </section>
    <section>
        <title>Writing Modules in Lua</title>
        <para>Lua modules are designed to be much easier to develop than a C equivalent. A Lua
            IronBee module is built like any other Lua module. Really all you need to do is to
            implement handlers which are executed when an event is triggered. These event handlers
            (prefixed with "onEvent" are automatically registered with the engine on load. Simply
            put the code you want executed in the appropriate handler and that is about it.</para>
        <programlisting>----------------------------------------------------------------------------
-- Define local versions of globals that will be used
----------------------------------------------------------------------------
local base = _G
local ironbee = require("ironbee")

----------------------------------------------------------------------------
-- Declare the rest of the file as a module and register the module
-- table with ironbee.
----------------------------------------------------------------------------
module(...)
ironbee.register_module(_M)

----------------------------------------------------------------------------
-- Setup some module metadata
----------------------------------------------------------------------------
_COPYRIGHT = "Copyright (C) 2010-2011 Qualys, Inc."
_DESCRIPTION = "IronBee example Lua module"
_VERSION = "0.1"

----------------------------------------------------------------------------
-- Event Handlers
--
-- NOTE: As a best practice, you should avoid using the "onEvent" prefix
-- in any public functions that are NOT to be used as event handlers as
-- these may be treated specially by the engine.
----------------------------------------------------------------------------

-- This is called when the request headers are avalable to inspect.
function onEventHandleRequestHeaders(...)
    local ib, tx = ...

    ironbee.log_debug(ib, 4, "Lua: %s.onEventHandleRequestHeaders", _NAME)
 
    -- Do something interesting

    return 0
end</programlisting>
    </section>
</chapter>
