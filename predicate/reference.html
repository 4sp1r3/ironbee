<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.9" />
<title>Predicate Reference</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install(2);
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
<h1>Predicate Reference</h1>
<span id="author">Christopher Alfeld</span><br />
<span id="email"><code>&lt;<a href="mailto:calfeld@qualys.com">calfeld@qualys.com</a>&gt;</code></span><br />
<div id="toc">
  <div id="toctitle">Table of Contents</div>
  <noscript><p><b>JavaScript must be enabled in your browser to display the table of contents.</b></p></noscript>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_introduction">Introduction</h2>
<div class="sectionbody">
<div class="paragraph"><p>This document is the reference manual for Predicate.  It contains precise descriptions of every aspect and function in the Predicate language.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_values">Values</h2>
<div class="sectionbody">
<div class="paragraph"><p>The value system of Predicate closely matches that of IronBee.  Values are named and typed.  Names are allowed to be any string, although, in practice, they tend to be short and human readible.</p></div>
<div class="paragraph"><p>There is a special value, <em>null</em>, written as <code>:</code>.  The null value has no name and no type.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">With the exception of null and lists, values are immutable.  See <a href="#_results">Results</a> below.</td>
</tr></table>
</div>
<div class="paragraph"><p>The types are:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
String
</dt>
<dd>
<p>
Strings can be of any length and can contain unprintable and null characters.
</p>
</dd>
<dt class="hdlist1">
Number
</dt>
<dd>
<p>
Numbers are signed 64 bit integers.
</p>
</dd>
<dt class="hdlist1">
Float
</dt>
<dd>
<p>
Floating points are long double precision floats.
</p>
</dd>
<dt class="hdlist1">
Lists
</dt>
<dd>
<p>
Lists are lists of values.
</p>
</dd>
<dt class="hdlist1">
Special
</dt>
<dd>
<p>
There are a few rare exceptions.  See <a href="#p.ask"><code>ask</code></a>.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>The null value is treated as false.  All other values are treated as true.</p></div>
<div class="paragraph"><p>At present, the canonical true value is the empty string, <code>''</code>.  However, this convention should not be relied upon.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_results">Results</h2>
<div class="sectionbody">
<div class="paragraph"><p>The result of any predicate expression is a value and a finished flag.  While the expression is not finished, certain changes to the value are allowed.  Once an expression is finished, its value is fixed.</p></div>
<div class="paragraph"><p>Values of unfinished expressions are only allowed to change in certain specific ways.  All expressions begin with the null value, <code>:</code>.  The allowed changes are:</p></div>
<div class="ulist"><ul>
<li>
<p>
Null to non-null.
</p>
</li>
<li>
<p>
Appending to a list value.
</p>
</li>
</ul></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">An expression that takes a non-null non-list value must be finished.  Also note that nodes may not change to the null value, only away from it.</td>
</tr></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_s_expressions">S-Expressions</h2>
<div class="sectionbody">
<div class="paragraph"><p>The underlying syntax of Predicate is that of an s-expression (sexpr).</p></div>
<div class="paragraph"><p>The grammar of a Predicate expression is:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>expression      := call | literal
call            := ' '* '(' name ( ' '+ expression )* ')'
name            := first_name_char name_char*
first_name_char := [A-Za-z_]
name_char       := first_name_char | [.-]
literal         := null | named_literal | literal_value
null            := ':'
named_literal   := literal_name ':' literal_value
literal_name    := string | name
literal_value   := list | string | float | integer
string          := '\'' (/[^'\\]/ | '\\\\' | '\\'')* '\''
integer         := '-'? [0-9]+
float           := '-'? [0-9]+ ('.' [0-9]+)?
list            := '[' ( literal ( ' '+ literal )* )? ']'</code></pre>
</div></div>
<div class="paragraph"><p>Note that many contexts, e.g., use in rules, requires the top expression to be a call.</p></div>
<div class="paragraph"><p>Informally:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Function Call
</dt>
<dd>
<p>
<code>(<em>name</em> <em>arg1</em> <em>arg2</em> &#8230;)</code>.  Call function <em>name</em> with given arguments.
</p>
</dd>
<dt class="hdlist1">
Null
</dt>
<dd>
<p>
<code>:</code>
</p>
</dd>
<dt class="hdlist1">
Named Literal
</dt>
<dd>
<p>
<code>name:value</code>.  Names can be written the same as strings, beginning and ending with <code>'</code>.  If the name satisfies the rules of function names, the <code>'</code>s can be omitted.
</p>
</dd>
<dt class="hdlist1">
Unnamed Literal
</dt>
<dd>
<p>
<code>value</code>
</p>
</dd>
<dt class="hdlist1">
String Value
</dt>
<dd>
<p>
E.g., <code>'hello world'</code>.  Single quotes can be embedded via <code>\'</code> and backslashes via <code>\\</code>.  More generally, <code>\x</code> is equivalent to <code>x</code> for any <code>x</code>.
</p>
</dd>
<dt class="hdlist1">
Number Value
</dt>
<dd>
<p>
E.g., <code>6</code>, <code>-13</code>.
</p>
</dd>
<dt class="hdlist1">
Float Value
</dt>
<dd>
<p>
E.g., <code>3.141</code>, <code>-7.0</code>.  The presence of a period distinguishes floats from numbers.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>List Values: <code>[value1 value2 &#8230;]</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_functions">Functions</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_arguments">Arguments</h3>
<div class="dlist"><dl>
<dt class="hdlist1">
Static
</dt>
<dd>
<p>
Static arguments must be literals.  Typically, a static argument requires some amount of preprocessing before it can be used, and this preprocessing should not be done at runtime.  E.g., a regular expression.
</p>
</dd>
<dt class="hdlist1">
Dynamic
</dt>
<dd>
<p>
Dynamic arguments are any that are not static.  All dynamic arguments may be literals.
</p>
</dd>
</dl></div>
</div>
<div class="sect2">
<h3 id="_categories">Categories</h3>
<div class="paragraph"><p>There are several categories of functions.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Primary
</dt>
<dd>
<p>
A primary function has a single "primary" argument that is always the last argument.  The function can be viewed as performing some sort of operation or transformation on the primary argument.  There may be additional "secondary" arguments that can be viewed as configuration of that operation.  A Primary function will do nothing (have a result of <code>:</code>) until all secondary arguments are finished.
</p>
</dd>
<dt class="hdlist1">
Map
</dt>
<dd>
<p>
A Map function is a Primary function that has a list primary argument and apply a subfunction to every subvalue of that list.  The result of a map function is the results of that subfunction.  If the primary argument is an actual list, <code>[value1, value2, &#8230;]</code>, the then result will be the subfunction <code>f</code> applied to each value: <code>[f(value1) f(value2) &#8230;]</code>.  If the primary argument is a null, the result will be a null.  If the primary argument is not a list, the result will be the subfunction applied to the argument.
</p>
</dd>
<dt class="hdlist1">
Filter
</dt>
<dd>
<p>
A Filter function is similar to Map, but instead of applying a subfunction to each subvalue, it chooses a subset based.  That is, it applies a subfunction to each subvalue and inclues the subvalue in the result iff the subfunction returns true.  If the primary argument is not a list, the result be the primary argument iff the subfunction is true when applied to the primary argument.
</p>
</dd>
<dt class="hdlist1">
Selector
</dt>
<dd>
<p>
A Selector function is similar to Filter, but instead of returning a list of passing subvalues, it returns the first passing subvalue.
</p>
</dd>
<dt class="hdlist1">
Abelian
</dt>
<dd>
<p>
An Abelian function behaves the same even if its argument are reordered.  This order independence can provide higher performance by merging calls that differ only in order.
</p>
</dd>
</dl></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_reference">Reference</h2>
<div class="sectionbody">
<div class="paragraph"><p>Every predicate function is described below.  Possible attributes are:</p></div>
<div class="paragraph"><p><strong>Result</strong>: The result of the function.</p></div>
<div class="paragraph"><p><strong>Finished</strong>: Conditions under which the function is finished.</p></div>
<div class="paragraph"><p><strong>Category</strong>: The category of the function.  Note that a category can imply many aspects of the function.  Those aspects will not be repeated in the specific function description.</p></div>
<div class="paragraph"><p><strong>See</strong>: Other related functions.</p></div>
<div class="paragraph"><p><strong>Arguments</strong>: Detailed information about arguments.  When Arguments is omitted, it can be assumed that all arguments are dynamic.</p></div>
<div class="paragraph"><p><strong>Transformations</strong>: How the function will transform.  When Transformations is omitted, the function may still transform according to its category.  Also, most function will transform if all of their arguments are literals.</p></div>
<div class="paragraph"><p><strong>Warning</strong>: Warnings about dangerous or unintuitive behavior.</p></div>
<div class="paragraph"><p><strong>Note</strong>: Notes about behavior.</p></div>
<div class="paragraph"><p><strong>Map</strong>: For map functions, the subfunction.</p></div>
<div class="paragraph"><p><strong>Filter</strong>: For filter functions, the filter.</p></div>
<div class="paragraph"><p><strong>Selector</strong>: For selector functions, the selector.</p></div>
<div class="paragraph"><p><strong>Deprecated</strong>: Why to avoid using this function and when it is going away.</p></div>
<div class="sect2">
<h3 id="_boolean">Boolean</h3>
<div class="paragraph"><p>These functions provide boolean logic functionality.</p></div>
<div class="sect3">
<h4 id="p.true"><code>(true)</code></h4>
<div class="paragraph"><p><strong>Result</strong>: N/A<br />
<strong>Finished</strong>: N/A</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<strong>Transformations</strong>
</dt>
<dd>
<p>
  <code>(true) &#8594; ''</code>
</p>
</dd>
</dl></div>
</div>
<div class="sect3">
<h4 id="p.false"><code>(false)</code></h4>
<div class="paragraph"><p><strong>Result</strong>: N/A<br />
<strong>Finished</strong>: N/A</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<strong>Transformations</strong>
</dt>
<dd>
<p>
  <code>(false) &#8594; :</code>
</p>
</dd>
</dl></div>
</div>
<div class="sect3">
<h4 id="p.and"><code>(and &#8230;) (andSC &#8230;)</code></h4>
<div class="paragraph"><p><strong>Category</strong>: Abelian (<code>and</code> only)<br />
<strong>Result</strong>: True iff all arguments are true or there are no arguments.<br />
<strong>Finished</strong>: All arguments are true or all arguments are finished.<br />
<strong>Note</strong>: <code>andSC</code> differs from <code>and</code> in that it is not abelian and will only evaluate an argument once all previous arguments are true.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<strong>Transformations</strong>
</dt>
<dd>
<p>
  <code>(and &#8230; : &#8230;) &#8594; :</code><br />
  <code>(and &#8230; x &#8230;) &#8594; (and &#8230; &#8230;)</code> if <code>x</code> is true literal<br />
  <code>(andSC &#8230; : &#8230;) &#8594; :</code><br />
  <code>(andSC &#8230; x &#8230;) &#8594; (and &#8230; &#8230;)</code> if <code>x</code> is true literal.
</p>
</dd>
</dl></div>
</div>
<div class="sect3">
<h4 id="p.or"><code>(or &#8230;)</code> <code>(orSC &#8230;)</code></h4>
<div class="paragraph"><p><strong>Category</strong>: Abelian (<code>or</code> only)<br />
<strong>Result</strong>: True iff any argument is true and there are arguments.<br />
<strong>Finished</strong>: Any argument is true or all arguments are finished.<br />
<strong>Note</strong>: <code>orSC</code> differs from <code>or</code> in that it is not abelian and will only evaluate an argument once all previous arguments are false and finished.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<strong>Transformations</strong>
</dt>
<dd>
<p>
  <code>(or &#8230; x &#8230;) &#8594; &apos;'</code> if <code>x</code> is true literal.<br />
  <code>(or &#8230; : &#8230;) &#8594; (or &#8230; &#8230;)</code>.<br />
  <code>(orSC &#8230; x &#8230;) &#8594; ''</code> if <code>x</code> is true literal.<br />
  <code>(orSC &#8230; : &#8230;) &#8594; (or &#8230; &#8230;)</code>.
</p>
</dd>
</dl></div>
</div>
<div class="sect3">
<h4 id="p.not"><code>(not a)</code></h4>
<div class="paragraph"><p><strong>Result</strong>: True iff <code>a</code> is false and finished.<br />
<strong>Finished</strong>: <code>a</code> is true or <code>a</code> is finished.<br />
<strong>Warning</strong>: The result will be false until <code>a</code> is finished, even if <code>a</code> is currently <code>:</code>.  This behavior is because, once the result becomes true it cannot return to false.</p></div>
</div>
<div class="sect3">
<h4 id="p.if"><code>(if p t f)</code> <code>(if p t)</code></h4>
<div class="paragraph"><p><strong>Arguments</strong>: <code>f</code> may be omitted, in which case it is treated as <code>:</code>.<br />
<strong>Result</strong>: <code>t</code> if <code>p</code> is true, <code>f</code> if <code>p</code> is false and finished, <code>:</code> otherwise.<br />
<strong>Finished</strong>: <code>t</code> is finished and <code>p</code> is true or <code>f</code> is finished and <code>p</code> is false and finished.<br />
<strong>Note</strong>: Interpreted as a short circuiting hint, e.g., "don&#8217;t evaluated <code>t</code> unless <code>p</code> is true".</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<strong>Transformations</strong>
</dt>
<dd>
<p>
  <code>(if p t f) &#8594; t</code> if <code>p</code> is true literal.<br />
  <code>(if : t f) &#8594; f</code>.<br />
  <code>(if p t) &#8594; t</code> if <code>p</code> is true literal.<br />
  <code>(if : t) &#8594; :</code>.
</p>
</dd>
</dl></div>
</div>
</div>
<div class="sect2">
<h3 id="_list">List</h3>
<div class="paragraph"><p>These function provide for manipulations of list values.</p></div>
<div class="sect3">
<h4 id="p.setName"><code>(setName n v)</code></h4>
<div class="paragraph"><p><strong>Category</strong>: Map<br />
<strong>Map</strong>: <code>x:y &#8594; n:y</code><br />
<strong>Note</strong>: To set the name of a list, use <code>(first (setName n (list v)))</code>.</p></div>
</div>
<div class="sect3">
<h4 id="p.pushName"><code>(pushName v)</code></h4>
<div class="paragraph"><p><strong>Category</strong>: Map<br />
<strong>Map</strong>: <code>x:y &#8594; n:y</code> where <code>n</code> is the name of <code>v</code>.<br />
<strong>Note</strong>: Useful with <a href="#p.flatten"><code>flatten</code></a> to flatten a list but preserve the names of the parent lists: <code>(flatten (pushName v))</code>.</p></div>
</div>
<div class="sect3">
<h4 id="p.cat"><code>(cat &#8230;)</code></h4>
<div class="paragraph"><p><strong>Arguments</strong>: All arguments are treated as list values, i.e., <code>:</code> is treated as <code>[]</code> and a non-list <code>v</code> is treated as <code>[v]</code>.<br />
<strong>Result</strong>: The concatenation of all arguments.  As the result can only be appended to, these are added as possible.  I.e., <code>cat</code> adds all the values of the first argument as they become available and only moves to the second argument once the first argument is finished, and so on.  If provided no arguments, the result will be <code>:</code>.<br />
<strong>Finished</strong>: All arguments are finished.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<strong>Note</strong>
</dt>
<dd>
<p>
  <code>cat</code> has, by a significant margin, the most complicated implementation.<br />
  In the future, a function that behaves like <code>cat</code> but does not preserve order and processes all arguments simultaneously will be added.
</p>
</dd>
<dt class="hdlist1">
<strong>Transformations</strong>
</dt>
<dd>
<p>
  <code>(cat) &#8594; []</code><br />
  <code>(cat &#8230; : &#8230;) &#8594; (cat &#8230; &#8230;)</code><br />
  <code>(cat &#8230; [] &#8230;) &#8594; (cat &#8230; &#8230;)</code><br />
  <code>(cat v) &#8594; v</code> if <code>v</code> is a list literal.
</p>
</dd>
</dl></div>
</div>
<div class="sect3">
<h4 id="p.list"><code>(list &#8230;)</code></h4>
<div class="paragraph"><p><strong>Result</strong>: <code>[&#8230;]</code>, i.e., a list of the values of the arguments.  Elements will be added as arguments finish, i.e., the first element will be added when the first argument is finished, and then <code>list</code> will consider the second argument.<br />
<strong>Finished</strong>: All arguments are finished.<br />
<strong>Warning</strong>: If no arguments are given, the result is <code>[]</code>, not <code>:</code>.<br /></p></div>
</div>
<div class="sect3">
<h4 id="p.first"><code>(first v)</code></h4>
<div class="paragraph"><p><strong>Category</strong>: Selector.<br />
<strong>Selector</strong>: First element.</p></div>
</div>
<div class="sect3">
<h4 id="p.rest"><code>(rest v)</code></h4>
<div class="paragraph"><p><strong>Category</strong>: Filter<br />
<strong>Fitler</strong>: Not first element.<br />
<strong>Finished</strong>: <code>v</code> is finished.</p></div>
</div>
<div class="sect3">
<h4 id="p.nth"><code>(nth n v)</code></h4>
<div class="paragraph"><p><strong>Category</strong>: Selector.<br />
<strong>Arguments</strong>: <code>n</code> must be a number.<br />
<strong>Selector</strong>: +n+th element.<br />
<strong>Notes</strong>: The first element is 1, not 0.</p></div>
</div>
<div class="sect3">
<h4 id="p.flatten"><code>(flatten v)</code></h4>
<div class="paragraph"><p><strong>Result</strong>: If <code>v</code> is <code>[a1 a2 &#8230;]</code>, then this behaves as <code>(cat a1 a2 &#8230;)</code> would.  Otherwise, the value is <code>v</code>.<br />
<strong>Finished</strong>: <code>v</code> is finished.<br />
<strong>Note</strong>: Sublists of <code>v</code> are immutable, only <code>v</code> is allowed to append.</p></div>
</div>
<div class="sect3">
<h4 id="p.focus"><code>(focus n v)</code></h4>
<div class="paragraph"><p><strong>Arguments</strong>: <code>n</code> must be a string.<br />
<strong>Result</strong>: <code>focus</code> acts like a filter and a map.  First, it filters <code>v</code> by selecting only elements that are lists containing elements named <code>n</code>.  Then it maps by replacing such a list with the element named <code>n</code> renamed to have the same name as the replaced list.  If <code>v</code> is not a list, then the result is <code>[]</code>.<br />
<strong>Finished</strong>: <code>n</code> is finished and <code>v</code> is finished.<br />
<strong>Note</strong>: <code>focus</code> is best viewed as selecting subresults.  For example, say you apply a regular expression to a list of inputs, resulting a list of capture collections named after the inputs.  You now want to select a specific capture from each capture collection will preserving the names of the input.  <code>focus</code> will do exactly that.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<strong>Transformations</strong>
</dt>
<dd>
<p>
  <code>(focus n v) &#8594; []</code> if <code>v</code> is a non-list literal.
</p>
</dd>
</dl></div>
</div>
</div>
<div class="sect2">
<h3 id="_string">String</h3>
<div class="sect3">
<h4 id="p.stringReplaceRx"><code>(stringReplaceRx e r v)</code></h4>
<div class="paragraph"><p><strong>Category</strong>: Map.<br />
<strong>Arguments</strong>: <code>e</code> and <code>r</code> must be literal strings.  <code>e</code> must be a valid regular expression and <code>r</code> a valid replacement string (according to <code>boost::regex</code>).  <code>v</code> must be a string or list of strings.<br />
<strong>Map</strong>: <code>x &#8594; y</code> where <code>y</code> has every substring of <code>x</code> matching <code>e</code> replaced with <code>r</code>.<br />
<strong>Deprecated</strong>: This function will eventually be removed once an IronBee transformation doing an equivalent task is available.</p></div>
</div>
<div class="sect3">
<h4 id="p.length"><code>(length v)</code></h4>
<div class="paragraph"><p><strong>Category</strong>: Map.<br />
<strong>Map</strong>: +x &#8594; length of x* if <strong>x</strong> is a string and null otherwise.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_filters">Filters</h3>
<div class="sect3">
<h4 id="p.eq"><code>(eq x v)</code></h4>
<div class="paragraph"><p><strong>Category</strong>: Filter.<br />
<strong>Filter</strong>: Subvalue is equal to <code>x</code> in type and value.<br />
<strong>Note</strong>: Unlikely to work as desired with float values.  A <code>near</code> function may be added in the future.<br />
<strong>Note</strong>: Lists are never equal, i.e., <code>(eq [1 2 3] <a id="1 2 3"></a>)</code> is <code>[]</code>, not <code><a id="1 2 3"></a></code>.  This may be changed in the future.</p></div>
</div>
<div class="sect3">
<h4 id="p.ne"><code>(ne x v)</code></h4>
<div class="paragraph"><p><strong>Category</strong>: Filter.<br />
<strong>Filter</strong>: Subvalue is equal to <code>x</code> in type and value.<br />
<strong>Note</strong>: See <a href="#p.eq"><code>eq</code></a> for related discussion.</p></div>
</div>
<div class="sect3">
<h4 id="p.lt"><code>(lt n v)</code></h4>
<div class="paragraph"><p><strong>Arguments</strong>: <code>n</code> must be a number of float.<br />
<strong>Filter</strong>: Number or float and less than <code>n</code>.</p></div>
</div>
<div class="sect3">
<h4 id="p.le"><code>(le n v)</code></h4>
<div class="paragraph"><p><strong>Arguments</strong>: <code>n</code> must be a number of float.<br />
<strong>Filter</strong>: Number or float and less than or equal to <code>n</code>.</p></div>
</div>
<div class="sect3">
<h4 id="p.gt"><code>(gt n v)</code></h4>
<div class="paragraph"><p><strong>Arguments</strong>: <code>n</code> must be a number of float.<br />
<strong>Filter</strong>: Number or float and greater than <code>n</code>.</p></div>
</div>
<div class="sect3">
<h4 id="p.ge"><code>(ge n v)</code></h4>
<div class="paragraph"><p><strong>Arguments</strong>: <code>n</code> must be a number of float.<br />
<strong>Filter</strong>: Number or float and greater than or equal to <code>n</code>.</p></div>
</div>
<div class="sect3">
<h4 id="p.typed"><code>(typed t v)</code></h4>
<div class="paragraph"><p><strong>Arguments</strong>: <code>t</code> must be a string literal and: <code>'number'</code>, <code>'float'</code>, <code>'list'</code>, or <code>'string'</code>.<br />
<strong>Filter</strong>: Type as described by <code>t</code>.</p></div>
</div>
<div class="sect3">
<h4 id="p.named"><code>(named n v)</code></h4>
<div class="paragraph"><p><strong>Arguments</strong>: <code>n</code> must be a string.<br />
<strong>Filter</strong>: Has name <code>n</code>.</p></div>
</div>
<div class="sect3">
<h4 id="p.namedi"><code>(namedi n v)</code></h4>
<div class="paragraph"><p><strong>Arguments</strong>: <code>n</code> must be a string.<br />
<strong>Filter</strong>: Has name <code>n</code>, possibly with case differences.</p></div>
</div>
<div class="sect3">
<h4 id="p.sub"><code>(sub n v)</code></h4>
<div class="paragraph"><p>Sub is an alias for <a href="#p.namedi"><code>namedi</code></a>.</p></div>
</div>
<div class="sect3">
<h4 id="p.namedRx"><code>(namedRx n v)</code></h4>
<div class="paragraph"><p><strong>Arguments</strong>: <code>n</code> must be a string literal and a valid regexp.<br />
<strong>Filter</strong>: Has name matching <code>n</code>.</p></div>
</div>
<div class="sect3">
<h4 id="p.longer"><code>(longer n v)</code></h4>
<div class="paragraph"><p><strong>Category</strong>: Filter.<br />
<strong>Arguments</strong>: <code>n</code> must be a number.<br />
<strong>Filter</strong>: Subvalue is list of more than <code>n</code> elements.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<strong>Transformations</strong>
</dt>
<dd>
<p>
  <code>(longer n v) &#8594; v</code> if <code>n</code> is 0.
</p>
</dd>
</dl></div>
</div>
</div>
<div class="sect2">
<h3 id="_predicates">Predicates</h3>
<div class="paragraph"><p>Predicates test their primary arguments are return true or false best on the result.</p></div>
<div class="sect3">
<h4 id="p.isLonger"><code>(isLonger n v)</code></h4>
<div class="paragraph"><p><strong>Arguments</strong>: <code>n</code> must be a number.<br />
<strong>Result</strong>: false until <code>n</code> is finished; then false until <code>v</code> is a list with more than <code>n</code> elements, then true.<br />
<strong>Finished</strong>: <code>n</code> is finished and either is true or <code>v</code> is a non-list.</p></div>
</div>
<div class="sect3">
<h4 id="p.isFinished"><code>(isFinished v)</code></h4>
<div class="paragraph"><p><strong>Result</strong>: false until <code>v</code> is finished, then true.<br />
<strong>Finished</strong>: <code>v</code> is finished.</p></div>
</div>
<div class="sect3">
<h4 id="p.isLiteral"><code>(isLiteral v)</code></h4>
<div class="paragraph"><p><strong>Result</strong>: N/A<br />
<strong>Finished</strong>: N/A</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<strong>Transformations</strong>
</dt>
<dd>
<p>
  <code>(isLiteral v) &#8594; ''</code> if <code>v</code> is a literal.<br />
  <code>(isLiteral v) &#8594; :</code> if <code>v</code> is not a literal.
</p>
</dd>
</dl></div>
</div>
<div class="sect3">
<h4 id="p.isList"><code>(isList v)</code></h4>
<div class="paragraph"><p><strong>Result</strong>: false while <code>v</code> is <code>:</code>, then true if <code>v</code> is a list and false otherwise.<br />
<strong>Finished</strong>: <code>v</code> is finished.<br />
<strong>Note</strong>: <code>isList</code> is one way to distinguish between the falsy values <code>:</code> and <code>[]</code>.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_math">Math</h3>
<div class="sect3">
<h4 id="p.add"><code>(add a b)</code></h4>
<div class="paragraph"><p><strong>Category</strong>: Map.<br />
<strong>Arguments</strong>: <code>a</code> must be a float or number.<br />
<strong>Map</strong>: <code>n:x &#8594; n:(a+x)</code> if <code>x</code> is numeric and <code>x</code> otherwise.<br />
<strong>Note</strong>: Result will be float if either side is a float.</p></div>
</div>
<div class="sect3">
<h4 id="p.neg"><code>(neg a)</code></h4>
<div class="paragraph"><p><strong>Category</strong>: Map.<br />
<strong>Map</strong>: <code>n:x &#8594; n:(-x)* if +x</code> is numeric and <code>x</code> otherwise.</p></div>
</div>
<div class="sect3">
<h4 id="p.mult"><code>(mult a b)</code></h4>
<div class="paragraph"><p><strong>Category</strong>: Map.<br />
<strong>Arguments</strong>: <code>a</code> must be a float or number.<br />
<strong>Map</strong>: <code>n:x &#8594; n:(a*x)</code> if <code>x</code> is numeric and <code>x</code> otherwise.<br />
<strong>Note</strong>: Result will be float if either side is a float.</p></div>
</div>
<div class="sect3">
<h4 id="p.recip"><code>(recip a)</code></h4>
<div class="paragraph"><p><strong>Category</strong>: Map.<br />
<strong>Map</strong>: <code>n:x &#8594; n:(1/x)* if +x</code> is numeric and <code>x</code> otherwise.<br />
<strong>Note</strong>: Result is always a float.</p></div>
</div>
<div class="sect3">
<h4 id="p.max"><code>(max v)</code></h4>
<div class="paragraph"><p><strong>Arguments</strong>: <code>v</code> must be a list.<br />
<strong>Result</strong>: Largest numeric element of <code>v</code> or empty list if no such element.<br />
<strong>Note</strong>: On ties, the first maximum element will be the result.<br />
<strong>Note</strong>: To compare results from two functions, use <a href="#p.cat"><code>cat</code></a>, e.g., <code>(max (cat (ref 'a') (ref 'b')))</code>.</p></div>
</div>
<div class="sect3">
<h4 id="p.min"><code>(min v)</code></h4>
<div class="paragraph"><p><strong>Arguments</strong>: <code>v</code> must be a list.<br />
<strong>Result</strong>: Largest numeric element of <code>v</code> or empty list if no such element.<br />
<strong>Note</strong>: On ties, the first minimum element will be the result.<br />
<strong>Note</strong>: To compare results from two functions, use <a href="#p.cat"><code>cat</code></a>, e.g., <code>(min (cat (ref 'a') (ref 'b')))</code>.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_phase">Phase</h3>
<div class="paragraph"><p>These are specialized functions used to closely control when evaluation occurs.</p></div>
<div class="paragraph"><p>A phase is specified via a literal strings describing an IronBee phase.  Valid values are:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>REQUEST_HEADER</code>
</p>
</li>
<li>
<p>
<code>REQUEST_HEADER_PROCESS</code>
</p>
</li>
<li>
<p>
<code>REQUEST</code>
</p>
</li>
<li>
<p>
<code>REQUEST_PROCESS</code>
</p>
</li>
<li>
<p>
<code>RESPONSE_HEADER</code>
</p>
</li>
<li>
<p>
<code>RESPONSE_HEADER_PROCESS</code>
</p>
</li>
<li>
<p>
<code>RESPONSE</code>
</p>
</li>
<li>
<p>
<code>RESPONSE_PROCESS</code>
</p>
</li>
<li>
<p>
<code>POSTPROCESS</code>
</p>
</li>
</ul></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">These functions never transform into literals.  Only use them on arguments that are known to be dynamic, e.g., expressions involving IronBee functions.</td>
</tr></table>
</div>
<div class="sect3">
<h4 id="p.waitPhase"><code>(waitPhase p v)</code></h4>
<div class="paragraph"><p><strong>Result</strong>: <code>:</code> until evaluated in phase <code>p</code> and <code>v</code> from then on.<br />
<strong>Finished</strong>: Phase is <code>p</code> or later and <code>v</code> is finished.<br />
<strong>Note</strong>: It is possible that <code>v</code> will be evaluated before phase <code>p</code> if it appears in another expression.<br /></p></div>
</div>
<div class="sect3">
<h4 id="p.finishPhase"><code>(finishPhase p v)</code></h4>
<div class="paragraph"><p><strong>Result</strong>: <code>v</code> until phase <code>p</code> and the value of <code>v</code> at phase <code>p</code> from then on.<br />
<strong>Finished</strong>: <code>v</code> is finished or phase is <code>p</code> or later.<br />
<strong>Note</strong>: This function makes a copy of the value of <code>v</code> at phase <code>p</code>.  This copy can be a significant performance cost for complicated values.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_ironbee">IronBee</h3>
<div class="paragraph"><p>These functions allow interaction with IronBee.  In particular, they allow the use of IronBee rule components (transformations, operations, and vars).  They are the primary means by which external data enters Predicate.</p></div>
<div class="sect3">
<h4 id="p.var"><code>(var n)</code></h4>
<div class="paragraph"><p><strong>Result</strong>: <code>:</code> if no var named <code>n</code>; value of var <code>n</code> otherwise.<br />
<strong>Finished</strong>: For non-list values, as soon as they have a value.  For list values, when the var reaches its final phase.<br />
<strong>Note</strong>: <code>var</code> never transforms.<br />
<strong>Warning</strong>: Vars are not required to have a final phase.  As such, this function may never be finished. <br />
<strong>Warning</strong>: Vars may not obey value semantics; in particular, they may change value.  The behavior of the var function with such vars is undefined.<br /></p></div>
</div>
<div class="sect3">
<h4 id="p.var2"><code>(var n w f)</code></h4>
<div class="paragraph"><p>This function behaves as <a href="#p.var">var</a> except that it assumes that the var has a wait phase of <code>w</code> and a final phase of <code>f</code>.  These assumptions are not enforced.  To enforce behavior, see <a href="#p.waitPhase">waitPhase</a> and <a href="#p.finishPhase">finishPhase</a>.  This function is primarily for modules that adds vars without properly registering wait and final phases.</p></div>
</div>
<div class="sect3">
<h4 id="p.ask"><code>(ask p v)</code></h4>
<div class="paragraph"><p><strong>Result</strong>: <code>:</code> if <code>v</code> is not a list.  Otherwise, value of asking collection <code>v</code> with parameter <code>p</code>.<br />
<strong>Finished</strong>: <code>v</code> is finished.<br />
<strong>Note</strong>: <code>v</code> never transforms.<br />
<strong>Note</strong>: This function is only useful for asking dynamic collections for values.  Such collections are provided by modules.</p></div>
</div>
<div class="sect3">
<h4 id="p.operator"><code>(operator n s v)</code> <code>(foperator n s v)</code></h4>
<div class="paragraph"><p><strong>Category</strong>: Map for <code>operator</code>; Filter for <code>foperator</code>.<br />
<strong>Arguments</strong>: <code>n</code> and <code>s</code> must be literals.<br />
<strong>Map</strong>: Apply operator named <code>n</code> with parameter <code>s</code> to each subvalue and take value of capture if true and <code>:</code> if false.<br />
<strong>Filter</strong>: Apply operator named <code>n</code> with parameter <code>s</code> and test if operator returns true.</p></div>
</div>
<div class="sect3">
<h4 id="p.transformation"><code>(transformation n s v)</code></h4>
<div class="paragraph"><p><strong>Category</strong>: Map.<br />
<strong>Arguments</strong>: <code>n</code> and <code>s</code> must be literals.<br />
<strong>Map</strong>: Apply transformation named <code>n</code> with parameter <code>s</code> to each subvalue.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_development">Development</h3>
<div class="paragraph"><p>These functions assist with testing Predicate or developing Predicate expressions.  They are not intend for use in production.</p></div>
<div class="sect3">
<h4 id="p.p"><code>(p &#8230;)</code></h4>
<div class="paragraph"><p><strong>Arguments</strong>: Must have at least one child.<br />
<strong>Result</strong>: Value of last argument.<br />
<strong>Finished</strong>: Last argument is finished.<br />
<strong>Note</strong>: Will output the value of each argument to stderr at every evaluation.</p></div>
</div>
<div class="sect3">
<h4 id="p.sequence"><code>(sequence s e d)</code> <code>(sequence s e)</code></h4>
<div class="paragraph"><p><strong>Arguments</strong>: If <code>d</code> is omitted, it is treated as <code>1</code>.<br />
<strong>Result</strong>: <code>[s s+d s+2d &#8230; e]</code>.<br />
<strong>Finished</strong>: When the entire range is produced.<br />
<strong>Note</strong>: Appends a single value at each evaluation.<br />
<strong>Note</strong>: <code>d</code> can be negative.<br />
<strong>Note</strong>: Infinite ranges are possible, e.g., by having <code>d</code> positive and <code>s &gt; e</code>.</p></div>
</div>
<div class="sect3">
<h4 id="p.identity"><code>(identity v)</code></h4>
<div class="paragraph"><p><strong>Result</strong>: <code>v</code><br />
<strong>Finished</strong>: When <code>v</code> is.<br />
<strong>Note</strong>: This function never transforms.  In contrast, <code>(cat v)</code> is semantically equivalent, but does transform.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_templates">Templates</h3>
<div class="paragraph"><p>Templates provide basic user defined substitution transformations.  They permit complex expressions to be expressed as simple expressions, allowing for improved error messages and fewer bytes in certain forms.  Ultimately, they expand out to full expressions tree, have subexpressions merged with all other expressions, and are treated no differently that had they been written out fully to begin with.</p></div>
<div class="paragraph"><p>Templates are defined as a name, a list of parameters, and an expression.  The result is a new function named name.  When called, that function binds its arguments to the list of parameters and transforms based on the expression.  The expression can refer to the parameters via the <a href="#p.ref"><code>ref</code></a> function.</p></div>
<div class="sect3">
<h4 id="p.ref"><code>(ref s)</code></h4>
<div class="paragraph"><p><strong>Result</strong>: N/A<br />
<strong>Finished</strong>: N/A<br />
<strong>Transformations:</strong>: Transforms into argument to parameter named <code>s</code>.</p></div>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated 2014-04-04 11:36:26 CDT
</div>
</div>
</body>
</html>
