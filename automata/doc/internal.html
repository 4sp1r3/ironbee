<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"/>
	<title>IronAutomata Internals</title>
	<meta name="author" content="Christopher Alfeld &lt;calfeld@qualys.com&gt;"/>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>

<p>This document can be rendered to HTML (or many other formats) with <a href="http://fletcherpenney.net/multimarkdown/">MultiMarkdown</a>.</p>

<p><strong>IronAutomata Internals</strong></p>

<p>Christopher Alfeld<br>
calfeld@qualys.com<br>
11/2012</p>

<p>This document provides notes on the internal workings of IronAutomata. It is written for developers intending to develop for IronAutomata. Developers interesting in using IronAutomata in their own code should see the doxygen documentation. Also see <code>example.md</code>.</p>

<p>It is assumed that the reader is familiar with using IronAutomata (see <code>example.md</code>) and the public API (see Doxygen).</p>

<h1 id="automatacapabilities">Automata Capabilities</h1>

<p>The automata that IronAutomata generators, manipulates, and executes are essentially deterministic or non-deterministic finite automata with an output function that maps nodes to sets of outputs. There are a few details, however:</p>

<h2 id="defaulttargets">Default Targets</h2>

<p>Nodes may specify a default target which is a node to use as the next node if no matching edge is found. This capability is sometimes referred to as a default edge, being viewed as an edge that is followed if no other edge matches the current input.</p>

<h2 id="epsilonedge">Epsilon Edge</h2>

<p>An epsilon edge is an edge that is followed on any input. Unlike the default edge, it is followed even if other edges also match, in which case, the automata is non-deterministic.</p>

<h2 id="non-advancing">Non-Advancing</h2>

<p>Edges, including the default edge, can choose whether they advance the input or not. A non-advancing edge will change the current node but not advance the input location.</p>

<h2 id="no-advance-no-output">No-Advance-No-Output</h2>

<p>An automata as a whole can declare No-Advance-No-Output which means that output should never be emitted unless the input was advanced on the last transition.</p>

<h2 id="varyingrequirements">Varying Requirements</h2>

<p>Different parts of IronAutomata have different requirements on the automata they use. Most of the optimizations are written to function on any automata. The Eudoxus execution engine requires deterministic automata and does not support epsilon edges.</p>

<p>Default edges, epsilon edges, and non-advancing are all representational details. Any automata with such features is semantically equivalent to an automata with none of them. The Translate Non-Advancing optimization can completely eliminate non-advancing edges in an automata. In the future, converters to eliminate epsilon or default edges may be written, or a non-deterministic-to-deterministic converter. In practical terms, however, representation matters and an automata that is small and elegant when non-deterministic can explode exponentially when made deterministic (see Dragon book).</p>

<h1 id="intermediateformat">Intermediate Format</h1>

<p>The Intermediate Format (IF) is the interface between generation, optimization, and compilation. It encompasses a variety of compromises to serve each domain and, as a result, is often adequate and rarely optimal.</p>

<p>It is expected that generation and optimization is allowed to use significant more resources than execution. As such, the IF does not need to be as compact as, e.g., the Eudoxus format. However, it must have some awareness of space constraints as IronAutomata is expected to be used with very large automata. As a result, the IF supports features such as multiedges and value bitmaps.</p>

<p>Another influence on the IF is the desire to do certain general optimizations within the IF rather than within each compiler. E.g., the IF directly represents the singly linked list structure for outputs.</p>

<h2 id="protobufvsintermediate::">Protobuf vs Intermediate::</h2>

<p>On disk, there is a single IF format: chunked and gzipped protobuf. In memory their are two formats, the protobuf format and the Intermediate:: classes. The latter adds a variety of useful methods for manipulation and translates IDs into pointers, but is otherwise a direct translation of the protobuf. The disadvantage of the Intermediate:: classes is that they require loading the entire automata into memory, i.e., there is no streaming interface. Generally, in C++, it is easier to use the Intermediate:: classes and not worry about the underlying protobuf.</p>

<h2 id="ids">IDs</h2>

<p>The protobuf uses unsigned 64 bit identifiers to refer to objects. These identifiers are translated to and from pointers by the Intermediate:: code. </p>

<p>There are two types of identifiers: node and output. These occupy separate spaces, so a node identifier can be the same number as an output identifier. There is no requirement that the identifiers be contiguous. However, 0 is reserved as no-referent identifier.</p>

<p>The IF identifiers should not be confused with the identifiers used by Eudoxus.</p>

<h2 id="chunking">Chunking</h2>

<p>The protobuf format is written to disk in one or more chunks. Each chunk is a unsigned 32 bit integer in network byte order indicating how many bytes remain in the chunk, followed by gzipped protobuf containing one or more Node, Output, or Graph messages.</p>

<p>It is possible to store an entire automata in a single chunk. There are two advantages to using multiple chunks:</p>

<ol>
<li>Certain automata operations can operate in a streaming manner, reading a single chunk into memory at a time. For example, the <code>to_dot</code> utility, loads a single chunk at a time.</li>
<li>Even when the entire automata is loaded into memory, the Intermediate:: reader and writer operate one chunk at a time. Thus, smaller chunks means smaller working space. For very large automata, this difference can be significant.</li>
</ol>

<h2 id="multi-edges">Multi-edges</h2>

<p>The IF supports representing multiple edges in the automata theory sense in a single Edge message. I.e., edges can have multiple values and are followed on inputs that match any of those values.</p>

<p>Values of edges can be represented in one of two different ways:</p>

<ol>
<li>As a vector of values.</li>
<li>As a 256 bit bitmap with 1s for each value.</li>
</ol>

<p>The Intermediate::Edge code contains methods for reading and writing values independently of the format as well as format specific methods and format conversion methods. Generally, edges with few values use vectors and edges with many values use bitmaps.</p>

<p>Note that some algorithms such as the Aho-Corasick pattern generator use sorted vectors of values.</p>

<h2 id="outputs">Outputs</h2>

<p>Outputs are byte sequences associated with nodes. A node may have more than one output and an output be emitted by more than one node. </p>

<p>The outputs are, at first glance, represented as singly linked lists. However, there is no requirements that each output object is referred to by only one other object. Thus outputs are actually represented as a tree, but a tree with only parent pointers; no child pointers. </p>

<p>This reverse-tree representation is by design. In particular, it works well with generators such as Aho-Corasick that take the outputs of one node and append them to the outputs of another.</p>

<p>There are a few &#8220;standard&#8221; output types. These are only conventions supported by the existing command line programs. Users of the API are free to use whatever outputs they wish. The standard outputs are:</p>

<ul>
<li>Length: An unsigned 32 bit integer stored in host byte order. This output is useful for substring searches where the desired knowledge is what portion of the output is the substring. Since outputs are generated along with the current input location (which, for Aho-Corasick is the byte after the last byte of the substring), the location can be combined with the length to calculate the substring. <code>ee -t length</code> will do exactly this and output the substring.</li>
<li>Integer: An unsigned 32 bit integer stored in host byte order. This output is similar to the previous, but <code>ee -t integer</code> will output the integer with no interpretation.</li>
<li>String: A sequence of bytes. <code>ee -t string</code> will directly output the string.</li>
<li>Accept: For automata that only need to distinguish between accept and reject nodes, a 1 as a 32 byte unsigned integer in host byte order is stored as the output of accept nodes.</li>
</ul>

<h1 id="generator:trie">Generator: Trie</h1>

<p>The Trie generator is the simplest generator. It is intended as a Hello World style example for generators.</p>

<p>The generator algorithm is essentially the add word algorithm from the Aho-Corasick generator. For a word to add, it follows existing edges as far as they go and then adds the missing edges.</p>

<p>There is no attempt (or capability in the IF) for path compression. As such, the result is a Trie rather than a Patricia trie. However, Eudoxus does support path compression and will automatically do so as part of compilation. Thus, while the IF is a Trie, the compiled Eudoxus automata is closer to a Patricia trie.</p>

<p>At present, the Trie generator exists only as a command line utility. At some point, an API version will likely be written. The command line utility uses the &#8220;Accept&#8221; output type.</p>

<h1 id="generator:aho-corasick">Generator: Aho-Corasick</h1>

<p>The Aho-Corasick (AC) generator builds automata that implement the Aho-Corasick algorithm. It comes in two versions, normal and pattern. Normal Aho-Corasick is a fairly direct implementation of the original AC paper and the IF has the capabilities (e.g., defaults, non-advancing edges) to directly represent such automata. Just replace &#8220;fail&#8221; with &#8220;default&#8221;.</p>

<p>Pattern AC is much more complicated algorithm. In principle, an AC Pattern is equivalent to a set of normal words, however, a pattern such as <code>\d\d\d\d</code> is equivalent to <span class="math">\( 10^4 = 10000 \)</span> words: <code>0000</code> through <code>9999</code>. Adding all possible words would be infeasible both in terms of generator execution time and automata space. The generator takes advantage that all such words have the same outputs and makes aggressive use of multiedges to represent the patterns compactly.</p>

<p>Both normal and pattern act in three stages, a shared initialization stage, separate repeated add stages, and a shared final stage. The initialization stage simply creates a start node. The normal add stage is essentially identical to the Trie generator. The pattern add stage is complex and described in detail below. The shared final stage adds in the default (&#8220;failure&#8221;) edges and merges output sets. It is written to work with multi-edges and supports the single-valued edges the normal add stage creates as a specific case of multi-valued edges.</p>

<p>At present, officially, mixing normal and pattern adds in the same automata will result in undefined behavior. In practice, although untested, problems should only occur if a normal add takes place after a pattern add. I.e., if all normal adds come first, it should work. The normal add assumes all edges are single valued.</p>

<p>The API allows arbitrary outputs to be associated with each dictionary entry. The command line utility uses the &#8220;Length&#8221; output type for normal AC and the
&#8220;String&#8221; output type for pattern AC. Note that for normal AC, the substring is the same as the matching dictionary entry.</p>

<h2 id="splitedge">Split Edge</h2>

<p>The Pattern AC algorithms depend on a sub-algorithm, split edge. The split edge algorithm takes a multi-valued edge and a subset of its values and splits the edge into two edges, one of which contains the specified subset, and one of which contains the remainder. Both edges have the same source node. A new target node is created for the new edge. The original target node is copied over to the new target node. This copy is deep, i.e., it copies the entire subtree.</p>

<pre><code>SplitEdge(edge, tokens):
    newEdge &lt;- AddEdge(source(edge), values(edge) - tokens)
    values(newEdge) &lt;- values(edge) &amp; tokens
    DeepCopy(target(newEdge), target(edge))
    return newEdge
</code></pre>

<p>The follow diagrams show splitting an edge with values <span class="math">\( \{a, b, c \} \)</span> on <span class="math">\( \{ b, c \} \)</span>.</p>

<figure>
<img src="internal_split_edge.png" alt="Deep Split Edge" id="split_edge" />
<figcaption>Deep Split Edge</figcaption></figure>



<h2 id="addpattern">Add Pattern</h2>

<p>Note that an AC Pattern can be viewed as a sequence of sets of inputs. In this view, a normal AC word is a sequence of sets of size 1. E.g., the pattern <code>\d\d\d\d</code> becomes <span class="math">\( \{0 \ldots 9\}\{0 \ldots 9\}\{0 \ldots 9\}\{0 \ldots 9\} \)</span> where <span class="math">\( \{0 \ldots 9\} \)</span> is shorthand for <span class="math">\( \{0, 1, 2, 3, 4, 5, 6, 7, 8, 9\} \)</span>.</p>

<p>As with the normal add algorithm, the add pattern algorithm will consider each element of the sequence in turn. In the normal case, at each element there is a single corresponding node in the AC Tree. In the pattern case, there may be multiple nodes. E.g., in</p>

<figure>
<img src="internal_add_pattern1.png" alt="Multiple nodes for a pattern." id="add_pattern1" />
<figcaption>Multiple nodes for a pattern.</figcaption></figure>



<p>The pattern <span class="math">\( \{ 1, 2, 3, 4, 5, 6 \} \)</span> would have two nodes, 2 and 3, at the second level of three.</p>

<p>The basic add algorithm, then looks like:</p>

<pre><code>AddPattern(startNode, pattern, output):
    lastNodes &lt;- {}
    currentNodes &lt;- {startNode}
    for each set inputs in pattern
        nextCurrentNodes &lt;- {}
        for each node node in currentNodes
            nextCurrentNodes &lt;- nextCurrentNodes &amp; AddPatternInner(inputs, node)
        lastNodes &lt;- currentNodes
        currentNodes &lt;- nextCurrentNodes
    for each node in lastNodes
        outputs(node) &lt;- {output}
</code></pre>

<p>Thus, the inner operation of add is considering a set of inputs for a node in the tree. It looks for edges with values in its input set. For edges whose values are subsets, it adds the target of the edge to the nodes to consider at the next stage and removes those values from its input set. For edges whose values intersect but are not subsets, it splits using Split Edge, yielding an edge that is the subset case and an edge with no shared values. After considering all edges, if any values remain in the inputs, it adds a new edge for those values.</p>

<pre><code>AddPatternInner(inputs, node):
    nextNodes &lt;- {}
    for each edge of node with values(edge) &amp; inputs != {}
        if values(edge) - inputs != {} # Not subset
            edge &lt;- SplitEdge(edge, values(edge) &amp; inputs)
        nextNodes &lt;- nextNode &amp; {target(edge)}
        inputs &lt;- inputs - values(edge)
    if inputs != {}
        newEdge &lt;- AddEdge(node, inputs)
        nextNodes &lt;- nextNode &amp; target(newEdge)
    return nextNodes
</code></pre>

<p>In the follow diagram, we have a tree for the pattern <span class="math">\( \backslash l \backslash w = \{a\ldots z\}\{a\ldots zA\ldots Z0 \ldots 9\} \)</span> and are adding the pattern <span class="math">\( \backslash w \backslash w = \{a\ldots zA\ldots Z0 \ldots 9\}\{a\ldots zA\ldots Z0 \ldots 9\} \)</span>.</p>

<figure>
<img src="internal_add_pattern2.png" alt="Adding \w\w to \l\w" id="add_pattern2" />
<figcaption>Adding \w\w to \l\w</figcaption></figure>



<p>The add algorithm stores all edge values as <em>sorted</em> vectors. Doing so allows easy set operations, e.g., <code>std::set_difference</code>.</p>

<h2 id="processfailures">Process Failures</h2>

<p>The process failures algorithm at heart is as described in the original AC paper:</p>

<pre><code>ProcessFailures(startNode):
    todo &lt;- []
    for each edge of startNode:
        fail(target(edge)) &lt;- startNode
        todo.push(target(edge))
    while todo != {}
        node &lt;- todo.pop()
        for each edge in node
            todo &lt;- todo + ProcessFailuresInner(startNode, node, edge)
</code></pre>

<p>The inner operation is responsible for calculating the failure for <code>target(edge)</code>. For normal AC, this would look like:</p>

<pre><code>ProcessFailuresInnerNormal(startNode, node, edge): # Example; not actually used
    current &lt;- fail(node)
    v &lt;- value(edge)
    s &lt;- target(edge)
    while true
        e &lt;- edge of current such that value(e) = v
        if e exists
            fail(s) &lt;- target(e)
            return s
        else
            current &lt;- fail(current)
            if current = startNode
                fail(s) &lt;- startNode
                return s
</code></pre>

<p>The issue with patterns is that <code>value(edge)</code> becomes <code>values(edge)</code>, all of which must be handled. Different values may have different failures. These pose a problem as, at the moment, there is only a single <code>target(edge)</code> and thus a single failure behavior. To accommodate this, when different failures are needed, <code>edge</code> will be split, duplicating <code>target(edge)</code>.</p>

<pre><code>ProcessFailuresInner(startNode, node, edge):
    inputs &lt;- values(edge)
    s &lt;- target(edge)

    if fail(s) already defined # Can happen due to shallow splits.
        return

    newTodo &lt;- [s]

    current &lt;- fail(node)
    while cs != {}
        for each edge e of current with values(e) &amp; inputs != {}
            if values(e) = inputs
                # Easy case
                fail(s) &lt;- target(e)
                inputs &lt;- {}
            else
                # Need to split edge
                newEdge &lt;- SplitEdge(edge, values(e) &amp; inputs)
                newTodo &lt;- newTodo + [target(newEdge)]
                fail(target(newEdge)) &lt;- target(e)
                inputs &lt;- inputs - values(e)
            if inputs = {}
                # Early break
                break
        if inputs != {}
            if current = startNode
                fail(s) &lt;- startNode
                inputs &lt;- {}
            else
                current &lt;- fail(current)
</code></pre>

<p>In the following diagram, <code>\l\w\d</code> has been added to the automata and then process failures called. The diagram illustrates <code>ProcessFailuresInner</code> for node 2 and the edge from 2 to 3.</p>

<figure>
<img src="internal_add_pattern3.png" alt="Processing Failures" id="add_pattern3" />
<figcaption>Processing Failures</figcaption></figure>



<p>Below is the completed automata. Note the added outputs.</p>

<figure>
<img src="internal_add_pattern4.png" alt="Final Automata" id="add_pattern4" />
<figcaption>Final Automata</figcaption></figure>



<h2 id="furtherimprovements">Further Improvements</h2>

<p>Further improvements over the current algorithms are possible, both for normal and pattern. The insight from the pattern algorithm is that the automata only needs to distinguish inputs in so far as it matters for determining distinct outputs. That is, a node in the AC tree needs to represent potential outputs and future failures; it is fine if it represents multiple inputs so long as those inputs are, in some sense, equivalent. In the following tree, node 2 represents 10 different inputs, but this is fine as all 10 inputs have the same output and failure behavior:</p>

<figure>
<img src="internal_ac_improve1.png" alt="One node, many inputs" id="ac_improve1" />
<figcaption>One node, many inputs</figcaption></figure>



<p>This role of nodes suggests that nodes that are equivalent in terms of future outputs and failure behavior could be merged. As a concrete example, consider, the following modification of the final automata from the previous section:</p>

<figure>
<img src="internal_ac_improve2.png" alt="Final Automata, Improved" id="ac_improve2" />
<figcaption>Final Automata, Improved</figcaption></figure>



<p>Nodes 5 and 5&#8217; were identical to nodes 4 and 4&#8217; and merged together.</p>

<p>Such merging of identical nodes is not specific to Pattern AC and could be done as a generic optimization.</p>

<p>There may also be potential for AC specific optimization, taking advantage of the relation of outputs via the prefix ordering and the tree structure of the automata. Developing such optimization is future work.</p>

<h1 id="optimization:optimizeedges">Optimization: Optimize Edges</h1>

<p>The intermediate format can represent a node and its edges in a variety of ways, some of which are more compact than others. For example, a node that advanced to node 1 on inputs 0&#8211;200 and node 2 on inputs 201&#8211;255 could use any of the following:</p>

<ul>
<li>An edge with 201 values and an edge with 55 values.</li>
<li>255 edges with one value.</li>
<li>An edge with 201 values and a default edge.</li>
<li>An edge with 55 values and a default edge.</li>
</ul>

<p>And many more possibilities besides. In addition, for any of these possibilities, each edge could represent its values with a vector or a bitmap.</p>

<p>The optimize edges optimization chooses a &#8220;best&#8221; representation for a given edge set. It operates on a node without considering the rest of the automata. It represents edges to minimize space based on the following assumptions:</p>

<ul>
<li>A vector based edge uses one byte per value.</li>
<li>A bitmap based edge uses 32 bytes regardless of the number of values.</li>
<li>A default edge uses less space than any valued edge.</li>
<li>An epsilon edges uses less space than any valued edge.</li>
</ul>

<p>The optimization will lose multiplicity information. That is, if there are multiple edges to node X on input Y, only one will be present after optimize edges is finished.</p>

<p>The current implementation is brute force. It calculates a map of target node to which inputs lead to it. If all 256 values lead to a target, then it uses the target with the most values as the default. It then builds edges for each target using a bitmap when the number of values exceeds 32. As a special case, if a target has all values, an epsilon edge is used.</p>

<h1 id="optimization:deduplicateoutputs">Optimization: Deduplicate Outputs</h1>

<p>The deduplicate outputs optimization looks for output objects with the same content and same next output (with no next output as a possible value) and merges them into the same object. It repeats until no changes are made. As an optimization, instead of looking at every output on each pass, on passes after the first, it only considers outputs whose next output was merged on the previous pass. I.e., outputs that were not possible to merge in the previous pass but may be possible now.</p>

<p>In the IF, outputs are stored as <em>intrinsic</em> singly linked lists. This can be problematic as there could be two outputs with large identical contents but different next outputs. In the IF, there is no way to share space for the identical contents. This issue is ameliorated in Eudoxus, which uses an output content table independent of the link structure. Thus, for Eudoxus, deduplicate outputs only saves space in terms of link structure cost (a few bytes per output) rather than content cost.</p>

<p>Note that deduplicate outputs is completely transparent from an execution standpoint. In particular, the order and multiplicity of outputs of a node is unchanged.</p>

<h2 id="improvededuplicateoutputs">Improve Deduplicate Outputs</h2>

<p>There is significant room for improvement if the order of outputs can be modified. Consider the following output structure:</p>

<figure>
<img src="internal_dedup1.png" alt="Output Deduplication, Initial" id="dedup1" />
<figcaption>Output Deduplication, Initial</figcaption></figure>



<p>The existing deduplicate outputs algorithm can reduce this to:</p>

<figure>
<img src="internal_dedup2.png" alt="Output Deduplication, Current" id="dedup2" />
<figcaption>Output Deduplication, Current</figcaption></figure>



<p>However, if the outputs are reordered, it could be reduced further to:</p>

<figure>
<img src="internal_dedup3.png" alt="Output Deduplication, Improved" id="dedup3" />
<figcaption>Output Deduplication, Improved</figcaption></figure>



<p>Implementing such an algorithm is future work.</p>

<h1 id="optimization:translatenon-advancing">Optimization: Translate Non-Advancing</h1>

<p>Translate Non-Advancing is a family of three related optimization algorithms. All three eliminate non-advancing edges from the automata. </p>

<p>The primary motivation for eliminating non-advancing edges is that it decreases the number of edges traversed per byte of input during execution. In a deterministic automata, if there are no non-advancing edges, then each byte of input traverses at most one edge. However, for two of the three algorithms, the resulting automata is usually larger and gains in speed from fewer transitions can be offset by cache performance. As always in such cases, good benchmarks are important.</p>

<p>All three algorithms have far greater effect if non-advancing edges do not result in output, either because the target has no output or because no-advance-no-output is set for the automata.</p>

<p>The basic idea is to search for a non-advancing edge (in the single value, automata theory sense) from <code>A</code> to <code>B</code> on input <code>c</code> such that no output is generated by <code>B</code>. In such cases, we &#8220;know&#8221; the next input, namely <code>c</code>, and so can determine the next edge of <code>B</code>. There are three cases:</p>

<ol>
<li>If there is no edge from <code>B</code> for <code>c</code>, then the execution will end. The original non-advancing edge can safely be removed.</li>
<li>If there is a unique edge from <code>B</code> on <code>c</code>, to <code>D</code>, then the non-advancing edge can be retargeted to <code>D</code> (whether it advances or not is changed to match what the <code>B</code> to <code>D</code> edge does).</li>
<li>If there are multiple edges from <code>B</code> on <code>c</code>, then the original non-advancing edge can be replaced with multiple edges retargeted as in the previous case.</li>
</ol>

<p>This search and replace operation is repeated until the automata stabilizes.</p>

<p>Note, again, that &#8220;edge&#8221; in the above is in the single-value automata theory sense, not in the multi-edge representation sense. In practice, even when case 2 applies, a single multi-edge may be replaced with multiple multi-edges, resulting in a larger automata, in terms of bytes.</p>

<p>The three variants are:</p>

<ul>
<li>Aggressive: As described above. Note that this will eventually eliminate every advancing edge in the automata.</li>
<li>Conservative: In case 3, does nothing. I.e., will not replace an edge with multiple edges. Note that in the deterministic case, case 3 never occurs and aggressive and conservative are equivalent.</li>
<li>Structural: This is a limited version of conservative that is aware of the existing multi-edge structure of the automata. It will do a similar search-and-replace operation, but will only replace if can do so within the existing structure, i.e., by retargeting a multi-edge.</li>
</ul>

<p>Note that the structural version never creates objects or changes values and thus is guaranteed to not grow the automata. As such, it is generally suggested that the structural version be run on automata that it may benefit, such as Aho-Corasick.</p>

<p>The aggressive and conservative variants are currently implemented in a brute force fashion. In particular, for each node, the algorithm looks at each of the 256 possible inputs in turn. For nodes where few values have the same target, this is not too bad, although for nodes with few edges it can result in many iterations that do nothing. For nodes where many values have the same target, this is grossly inefficient. The space usage is ameliorated by optimizing the edges of each node before proceeding to the next, but the algorithm takes far more time than it could. An improved version would operate on a per-target or per-multi-edge basis, rather than a per input value basis. The algorithms could be further improved by intelligently limiting what edges are considered based on what edges changed in the previous pass. Such enhancements are left for future work.</p>

<p>In contrast, the structural version operates on a per-multi-edge basis and, as such, is far faster. However, it is both highly limited in what it can do and its behavior depends on how the edges of a node are mapped onto multi-edges. E.g., if every multi-edge has a single value, it will behave equivalently (and faster than) the conservative variant, but edges with multiple values may prevent operations that the conservative variant could perform.</p>

<p>Examples of each variant are in <code>example.md</code>.</p>

<h1 id="utility:variablelengthstructures">Utility: Variable Length Structures</h1>

<p>Eudoxus makes extensive use of variable length structures (VLS). Variable length structures are similar to normal structures except that their data members may be optional or have variable length. The VLS code is generic and could be used in other application where highly compact data structures are needed.</p>

<p>The use of variable length structures is well documented in <code>vls.h</code>. Internally, a state variable holds a pointer to the current location in the structure and macros both conditionally extract and advance the pointer.</p>

<h1 id="utility:bufferassembly">Utility: Buffer Assembly</h1>

<p>The buffer assembly code provides mechanisms for building up regions of memory. For example, it includes a templated function for appending a structure to the end of the buffer. The code is described in <code>buffer.hpp</code>.</p>

<p>An important aspect of using the buffer assembly code is the difference between pointers and indices. Pointers, e.g,. to a just appended structure, allow direct access may not be preserved in the future as the assembler may move the data into larger allocations. Indices are counted from the beginning of the buffer and are preserved. Methods exist for converting between indices and pointers.</p>

<h1 id="eudoxus">Eudoxus</h1>

<p>Eudoxus is currently the only execution engine in IronAutomata. Some important aspects:</p>

<ul>
<li>Oriented at compact representation of automata.</li>
<li>Supports only deterministic automata and does not support epsilon edges.</li>
<li>Execution engine is written in C.</li>
<li>Handles outputs via callbacks. Callbacks may terminate automata execution.</li>
<li>Also supports querying of current or final nodes outputs.</li>
<li>Supports streaming: executing on data in a series of calls.</li>
<li>Endian dependent: automata must be compiled for the same endianness that they are executed in.</li>
</ul>

<p>The API of Eudoxus execution is in <code>eudoxus.h</code>. The API of the compiler is in <code>eudoxus_compiler.hpp</code>. The command line compiler is <code>ec.hpp</code> and the command line executor is <code>ee.hpp</code>.</p>

<h2 id="automataformat">Automata Format</h2>

<p>Automata are represented in a custom format. The on disk and in memory representations are identical. Thus, loading an automata involves only loading the data into memory, some basic validation of version and endianness, and setting up a small, fixed amount of state, including a pointer to the data.</p>

<p>Automata objects, including nodes and outputs, are referred to with IDs which are the index of the first byte of the object in the automata data. IDs are unsigned integers. The width of an ID can be varied. E.g., an automata that fits in less than 256 bytes will use an ID width of 1 byte, whereas an automata larger than 4 gigabytes will require an ID width of 8 bytes.</p>

<p>The automata begins with a header containing:</p>

<ul>
<li>Version. This is checked for compatibility at automata load.</li>
<li>ID width.</li>
<li>Endianness. Also checked for compatibility at automata load.</li>
<li>No-Advance-No-Output.</li>
<li>Number of nodes, outputs, and output lists. These are not actually used by the execution engine but are provided to aid other tools involve Eudoxus automata.</li>
<li>Length of the automata data, including the header.</li>
<li>Index of the start node. The start node is the first object after the header, but there may be some amount of padding between the header and the start node.</li>
<li>Index of the first output list. This index is used to determine whether an ID refers to an output or an output list, allowing the elimination of an output list object for an output with no next output.</li>
</ul>

<p>Following the header are sections for node, output, and output list objects, in that order. It is not required that objects be perfectly packed. Padding may be inserted between objects, e.g., to align objects to certain byte boundaries.</p>

<p>An output object is length and content. An output list object is the ID of an output object and the ID of the next object. The next object may either be an output object or an output list object. Which is determined by comparing it to the index of the first output list stored in the header.</p>

<p>There are three types of node objects:</p>

<ul>
<li>Low Degree Nodes represent edges as a vectors of value, target pairs.</li>
<li>High Degree Nodes represent edges as bitmaps and vectors of targets.</li>
<li>Path Compression Nodes represent linear sequences of automata nodes.</li>
</ul>

<p>Every node has a flag indicating whether it has any outputs and, if set, the ID of the first output.</p>

<p>Low degree nodes add the following flags:</p>

<ul>
<li><code>has_nonadvancing</code>: Do any edges not advance.</li>
<li><code>has_default</code>: Is there a default edge.</li>
<li><code>advance_on_default</code>: Does the default edge advance.</li>
<li><code>has_edges</code>: Are there any non-default edges.</li>
</ul>

<p>In addition the object contains the degree (if there are edges), the default target (if there is a default edge), and a bitmap indexed by edge of index of whether an edge advances (if there are edges and some of them do not advance). Finally, if there are edges, they are appended as a vector of value, target pairs. At present, no requirements are placed on the order of edges but future versions may require a specific order.</p>

<p>High degree nodes add the <code>has_nonadvancing</code>, <code>has_default</code>, and <code>advance_on_default</code> flags that low degree nodes do. In addition, they add two more flags:</p>

<ul>
<li><code>has_target_bm</code>: Is there a bitmap indicating which values have targets.</li>
<li><code>has_ali_bm</code>: Is there a bitmap indicating when to advance the lookup index.</li>
</ul>

<p>In addition the objects contains the default target (if there is a default edge), a bitmap of whether a value advances (if there are non-advancing edges), a bitmap of whether a value has a target (if <code>has_target_bm</code> is set), and an Advance-Lookup-Index (ALI) bitmap, described below. Finally, the targets are appended as a vector of IDs.</p>

<p>The <code>target</code> and <code>ali</code> bitmaps interact to determine the index in the targets vector for a given value. In the basic case, there is no <code>ali</code> bitmap. To determine the index of a value, the number of 1s before that value are counted in the <code>target</code> bitmap. This case requires that every targeted value has an entry in the targets vector. For nodes with edges representing ranges of values, a more compact representation is available where a single entry in the targets vector represents a consecutive sequence of values. This behavior is supported with the <code>ali</code> bitmap. When the <code>ali</code> bitmap is present, the <code>target</code> bitmap determines whether a value has a target or not, but the (potentially different) <code>ali</code> bitmap is used to determine the index, again by counting the number of 1s before the value. The <code>ali</code> bitmap thus indicates at which values the index into the targets vector should be advanced, hence Advance-Lookup-Index.</p>

<p>There are special cases. If every value has a target, the <code>target</code> bitmap would be all 1s and can be omitted. In this case, the <code>ali</code> bitmap is still optional. If both bitmaps are omitted, then the index for a value is the value itself, i.e., there the targets vector will have 256 entries.</p>

<p>Path compression nodes represent a sequence of automata nodes. Each node in the sequence must have the default behavior (target and advance). Only the initial node in the sequence is allowed to have outputs. And each node in the sequence has exactly one non-default edge and that edge must advance, i.e., a single value. Path compression nodes are common, for example, in Tries.</p>

<p>Path compression nodes add the <code>has_default</code> and <code>advance_on_default</code> flags of the low node. In addition, an <code>advance_on_final</code> flag is added indicating whether to advance if the full path is completed. The remaining three flags encode the length of the path as 2, 3, 4, or more than 4. Paths of length 1 are not supported: such single-edge nodes can be represented as equally compactly as low nodes. Paths of length greater than 4 will have there length stored later in the node.</p>

<p>A final target ID is always present. There is also a default ID if <code>has_default</code> is set, the length if needed, and then two or more values describing the path.</p>

<p>The semantic behavior of a path compression node is to emit outputs on entrance, consumes inputs as long as they match the path, and then goes to the final target or default target as appropriate.</p>

<h2 id="execution">Execution</h2>

<p>The execution engine interprets the automata as required by the format (see above).</p>

<p>One aspect of execution is the use of subengines. There are four subengines, one for each of the ID widths: 1, 2, 4, and 8. The subengines have otherwise identical code and make use of macro metaprogramming to share source code. It is dubious whether this provides meaningful performance gain, however, it does allow the code to treat identifiers naturally and for the compiler to do type checking.</p>

<p>The subengine node data is defined in <code>eudoxus_subautomata.h</code> and the code in <code>eudoxus_subengine.c</code>. These files are included, four times, in <code>eudoxus_automata.h</code> and <code>eudoxus_engine.c</code>, respectively. The <code>eudoxus_subautomata.h</code> files also defines a traits template for C++ usage, e.g., the compiler.</p>

<p>Output for all nodes types is handled in a single routine. Each node type defines its own next function to determine the next node. The overall next function simply demuxes by node type. The execute function loops so long as their is input and a next node, running the output function for the current node and then the next function. The top most, public API, functions demux to specific subengine based on id width.</p>

<p>The <code>target</code> and ALI <code>bitmaps</code> are used via a population count function. This function in turn calls the built in gcc popcount function. There are known techniques for improving naive popcount performance by storing additional summary data about the bitmap. However, many modern CPUs include hardware popcount support. Eudoxus does not store additional summary information and hopes for hardware support.</p>

<h2 id="compiler">Compiler</h2>

<p>The compiler is written in C++ and, as with the execution engine, is made up of four subcompilers, one for each ID width. As this is C++, this is done via templates rather than macros.</p>

<p>Determining ID width is done simply. The compiler tries ID width 1 and, if it grows beyond 256 bytes, restarts with ID width 2, and so on. This could be improved for large automata by completing a compilation at a smaller ID width (IDs would be bogus) to gain a count of the number of IDs and then calculating the optimal size. For small to moderate automata, this would be slower than the early abort and increment approach. E.g., for automata that fit in an ID width of 2 (65K) but are significantly larger than 256 bytes, the current approach takes slightly over one compilation, whereas the other approach would take two: the first to count IDs and the second to compile with the proper ID width.</p>

<p>Compilation is done in two stages. In the first stage, all objects are laid out but any IDs are left unset. The locations of these IDs and what objects they refer to are stored in maps. As the objects are laid out their own IDs are also stored. In the second stage, now that the IDs of all objects are known, all IDs in the data are filled in. I.e., in the first pass the locations of objects are calculated and in the second pass any references to these locations are filled in.</p>

<p>The compiler uses path compression nodes whenever conditions permit. It decides between high and low nodes by calculating the number of bytes each would take and using whichever is smaller. From a time performance view, this approach favors low nodes too strongly. This choice can be adjusted by setting a high node weight (see <code>example.md</code>).</p>

<p>To avoid repeating calculations about IF data, a NodeOracle is used. The NodeOracle does all needed calculations once and the compiler then asks the oracle for the results as needed.</p>

</body>
</html>
