////
This file is intended to be read in HTML via translation with asciidoc.
////

= ClippScript Manual
Christopher Alfeld <calfeld@qualys.com>
:toc2:
:toclevels: 1

== Introduction

ClippScript is a Ruby based DSL for producing inputs for CLIPP.  It primarily produces inputs in the CLIPP PB format.

== Using ClippScript from the Command Line

ClippScript can be used on the command line.  Write a ClippScript file and then turn it into PB, JSON, or Ruby Hash via `clippscript.rb`.  Note that `clippscript.rb` requires Ruby 1.9.

----
clippscript.rb example.cs > example.pb
----

To output Ruby Hash or JSON, pass `--ruby` or `--json` as the first argument, respectively.

You can avoid the intermediate file by feeding the output directly into `clipp`:

----
clippscript.rb example.cs | clipp pb:- view
----

== Using ClippScript in CLIPP Test

To use ClippScript in CLIPP Test, simply pass a block of ClippScript in to the `clipp()` call.  E.g.,

----
def tc_clippscript
  clipp(consumer: 'view') do
    transaction do |t|
      t.request(raw: 'GET /foo HTTP/1.1')
    end
  end
end
----

All inputs generated by ClippScript are appended to the `:input_hashes` argument.

== Hello World

Here is a simple Hello World is ClippScript:

----
connection(id: 'HelloWorld') do |c|
  c.transaction do |t|
    t.request(
      method: 'GET',
      uri: '/hello/world',
      protocol: 'HTTP/1.9',
      headers: {
        'Host' => 'Foo.Com',
        'Content-Length' => 0
      },
      body: "Hello World!"
    )
  end
end
----

Here is the output as Ruby Hash (`clippscript.rb --ruby helloworld.cs`):

----
[{:id=>"HelloWorld",
  :connection=>
   {:pre_transaction_event=>
     [{:which=>1,
       :connection_event=>
        {:local_ip=>"1.2.3.4",
         :local_port=>80,
         :remote_ip=>"5.6.7.8",
         :remote_port=>1234}}],
    :transaction=>
     [{:event=>
        [{:which=>5,
          :request_event=>
           {:method=>"GET", :uri=>"/hello/world", :protocol=>"HTTP/1.9"}},
         {:which=>6,
          :header_event=>
           {:header=>
             [{:name=>"Host", :value=>"Foo.Com"},
              {:name=>"Content-Length", :value=>"0"}]}},
         {:which=>7},
         {:which=>8, :data_event=>{:data=>"Hello World!"}},
         {:which=>9}]}],
    :post_transaction_event=>[{:which=>4}]}}]
----

== Top-Level Directives

ClippScript has three top-level directives of increasing specificity.

=== `input(options) do |c|`

`input` begins a new input (equivalent to a single connection).  It provides a `connection` object with no pre-defined events.

**Options:**

`id`:: The ID of the input.  Defaults to "ClippScript".

=== `connection(options) do |c|`

`connection` begins a new input and provides a `connection object`; it automatically defines Connection Opened and Connection Closed events.

**Options:**

`id`:: The ID of the input.  Defaults to "ClippScript".

`local_ip`:: Local IP address.

`local_port`:: Local port number.

`remote_ip`:: Remote IP address.

`remote_port`:: Remote port number.

=== `transaction(options) do |t|`

`transaction` begins a new input, defines Connection Opened and Connection Closed events, adds a single transaction, and provides a `transaction` object.

**Options:**

`id`:: The ID of the input.  Defaults to "ClippScript".

`local_ip`:: Local IP address.

`local_port`:: Local port number.

`remote_ip`:: Remote IP address.

`remote_port`:: Remote port number.

== Connection

The top level directives `input` and `connection` both provide connection objects to their blocks.  The connection object can be used to define transactions with `c.transaction` and connection level events.

=== `c.transaction do |t|`

Begins a transaction and provides a `transaction` object.

=== `c.connection_opened(options)`

Adds a Connection Opened pre-event.  Will raise an error if any pre-events already exist.

**Options:**

`local_ip`:: Local IP address.

`local_port`:: Local port number.

`remote_ip`:: Remote IP address.

`remote_port`:: Remote port number.

`pre_delay`:: How long in seconds to delay before event.  Can be floating point.

`post_delay`:: How long in seconds to delay before event.  Can be floating point.

=== `c.connection_closed(options)`

Adds a Connection Closed post-event.  Will raise an error if any post-events already exist.

**Options:**

`pre_delay`:: How long in seconds to delay before event.  Can be floating point.

`post_delay`:: How long in seconds to delay before event.  Can be floating point.

=== `c.pre_event(which, options)`

Adds a pre-event.  See Event Methods below.

=== `c.post_event(which, options)`

Adds a post-event.  See Event Methods below.

== Transaction

The `c.transaction` method provides a transaction object to its block.  The transaction object can be used to define transaction events, either directly or via a variety of helper routines.

There are three levels of helper routines:

- The highest level are `t.request` and `t.response` which define an entire requests and response, respectively.  Each generates all the events necessary for an entire request/response.  However, these do not allow for splitting headers or data across multiple events or for delaying events.
- The next level has a method for each event and two helper routines: `t.headers` and `t.body` which provide some basic sanity checking, auto event typing, and a simpler interface.
- At the lowest level is `t.event`.

=== `t.request(options)`

Adds events for an entire request including Request Started, Request Header, Request Header Finished, Request Body, and Request Finished.  All heads will be in a single request header event and the body will be in a single Request Body event.

**Options:**

`headers`:: Hash of header name to value of all request headers. If the value is a list, each value is inserted as a separate header instance with the same name.

`body`:: String of body data.

`raw`:: The entire request line.

`method`, `uri`, `protocol`:: The components of the request line.

=== `t.response(options)`

As `t.request`, but generates events for a response instead.

**Options:**

`headers`:: Hash of header name to value of all response headers.

`body`:: String of body data.

`raw`:: The entire response line.

`protocol`, `status`, `message`:: The components of the response line.

=== `t.headers(headers)`

Adds a Request/Response Header event and a Request/Response Header Finished event.  The `headers` parameter should be a hash of header name to value.  Must come immediately after a Request Started or Response Started event.  To split headers across events or to add delays, use `t.request_header` or `t.response_header`.

=== `t.body(body)`

Adds a Request/Response Body event.  The `body` parameter should be a string of body data.  Must come immediately after either a Request/Response Started event or a Request/Response Header Finished event.  To split body data across events or to add delays, use `t.request_body` or `t.response_body`.

=== `t.request_started(options)`

Generate a Request Started event.

**Options:**

`raw`:: The entire request line.  Optional if 'method', 'uri', and 'protocol' are present.

`method`, `uri`, `protocol`:: The components of the request line.  Optional if `raw` is present.

`pre_delay`:: How long in seconds to delay before event.  Can be floating point.

`post_delay`:: How long in seconds to delay before event.  Can be floating point.

=== `t.response_started(options)`

Generate a Response Started event.

**Options:**

`raw`:: The entire response line.  Optional if 'protocol', 'status', and 'message' are present.

`protocol`, `status`, `message`:: The components of the response line.  Optional if `raw` is present.

`pre_delay`:: How long in seconds to delay before event.  Can be floating point.

`post_delay`:: How long in seconds to delay before event.  Can be floating point.

=== `t.request_header(options)`

Generate a Request Header event.

**Options:**

`headers`:: Hash of header name to value.

`pre_delay`:: How long in seconds to delay before event.  Can be floating point.

`post_delay`:: How long in seconds to delay before event.  Can be floating point.

=== `t.response_header(options)`

Generate a Response Header event.

**Options:**

`headers`:: Hash of header name to value.

`pre_delay`:: How long in seconds to delay before event.  Can be floating point.

`post_delay`:: How long in seconds to delay before event.  Can be floating point.

=== `t.request_header_finished(options)`

Generate a Request Header Finished event.

**Options:**

`pre_delay`:: How long in seconds to delay before event.  Can be floating point.

`post_delay`:: How long in seconds to delay before event.  Can be floating point.

=== `t.response_header_finished(options)`

Generate a Response Header Finished event.

**Options:**

`pre_delay`:: How long in seconds to delay before event.  Can be floating point.

`post_delay`:: How long in seconds to delay before event.  Can be floating point.

=== `t.request_body(options)`

Generate a Request Body event.

**Options:**

`data`:: Body data.

`pre_delay`:: How long in seconds to delay before event.  Can be floating point.

`post_delay`:: How long in seconds to delay before event.  Can be floating point.

=== `t.response_body(options)`

Generate a Response Body event.

**Options:**

`data`:: Body data.

`pre_delay`:: How long in seconds to delay before event.  Can be floating point.

`post_delay`:: How long in seconds to delay before event.  Can be floating point.

=== `t.request_finished(options)`

Generate a Request Finished event.

**Options:**

`pre_delay`:: How long in seconds to delay before event.  Can be floating point.

`post_delay`:: How long in seconds to delay before event.  Can be floating point.

=== `t.response_finished(options)`

Generate a Response Finished event.

**Options:**

`pre_delay`:: How long in seconds to delay before event.  Can be floating point.

`post_delay`:: How long in seconds to delay before event.  Can be floating point.

=== `t.connection_data_in(options)`

Generate a Connection Data In event.

**Options:**

`data`:: Connection data.

`pre_delay`:: How long in seconds to delay before event.  Can be floating point.

`post_delay`:: How long in seconds to delay before event.  Can be floating point.

=== `t.connection_data_out(options)`

Generate a Connection Data Out event.

**Options:**

`data`:: Connection data.

`pre_delay`:: How long in seconds to delay before event.  Can be floating point.

`post_delay`:: How long in seconds to delay before event.  Can be floating point.

=== `t.event(which, options)`

Adds an event.  See Event Methods below.

== Event Methods

There are three event methods, providing low level access to event generation -- `c.pre_event`, `c.post_event`, and `t.event` -- which adds pre-transaction events, post-transaction events, and transaction events, respectively.  All take a `which` parameter and a set of `options`.  The `which` parameter is the numeric identifier of the event type.  ClippScript defines constants for all event types:

----
CONNECTION_OPENED        = 1
CONNECTION_DATA_IN       = 2
CONNECTION_DATA_OUT      = 3
CONNECTION_CLOSED        = 4
REQUEST_STARTED          = 5
REQUEST_HEADER           = 6
REQUEST_HEADER_FINISHED  = 7
REQUEST_BODY             = 8
REQUEST_FINISHED         = 9
RESPONSE_STARTED         = 10
RESPONSE_HEADER          = 11
RESPONSE_HEADER_FINISHED = 12
RESPONSE_BODY            = 13
RESPONSE_FINISHED        = 14
----

The `options` parameter is a hash of options.  The options `pre_delay` and `post_delay` are interpreted appropriately.  All other options are placed directly as event data.  For what these are and their meanings, see `clipp.proto`.

== ClippScript API

ClippScript can be loaded and used as a module, `ClippScript`.  The module can be included to define the top-level directives: `input`, `connection`, and `transaction`.  There are three other ways of using it:

=== `ClippScript::eval(what) do |input|`

The `what` parameter must be a string of ClippScript text, or a Proc of ClippScript.  In either case, it evaluates `what` and calls the block with each input as a Ruby Hash.

Returns nil.

=== `ClippScript::eval(what)`

As above, but returns the inputs as an array of Ruby Hashes.

=== `ClippScript::Environment.new do |input|`

The resulting class defines the top-level directives and calls the block passed to the initializer for each input defined using them.  It also defines `#get_binding` which returns a binding with `self` set to it, i.e., one suitable for use with `Kernel::eval`.

