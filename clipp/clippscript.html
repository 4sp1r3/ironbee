<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"/>
	<title>ClippScript Manual</title>
	<meta name="author" content="Christopher Alfeld &lt;calfeld@qualys.com&gt;"/>
</head>
<body>

<p>ClippScript Manual</p>

<p>Christopher Alfeld <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#111;&#58;&#99;&#x61;&#x6c;&#102;&#x65;&#108;&#100;&#x40;&#x71;&#x75;&#x61;&#108;&#121;&#x73;&#x2e;&#x63;&#x6f;&#109;">&#x63;&#x61;&#108;&#102;&#x65;&#x6c;&#100;&#64;&#x71;&#117;&#x61;&#x6c;&#x79;&#x73;&#x2e;&#x63;&#111;&#x6d;</a><br></p>

<h1 id="introduction">Introduction</h1>

<p>ClippScript is a Ruby based DSL for producing inputs for CLIPP. It primarily produces inputs in the CLIPP PB format.</p>

<h1 id="usingclippscriptfromthecommandline">Using ClippScript from the Command Line</h1>

<p>ClippScript can be used on the command line. Write a ClippScript file and then turn it into PB, JSON, or Ruby Hash via <code>clippscript.rb</code>. Note that <code>clippscript.rb</code> requires Ruby 1.9.</p>

<pre><code>clippscript.rb example.cs &gt; example.pb
</code></pre>

<p>To output Ruby Hash or JSON, pass <code>--ruby</code> or <code>--json</code> as the first argument, respectively.</p>

<p>You can avoid the intermediate file by feeding the output directly into <code>clipp</code>:</p>

<pre><code>clippscript.rb example.cs | clipp pb:- view
</code></pre>

<h1 id="usingclippscriptinclipptest">Using ClippScript in CLIPP Test</h1>

<p>To use ClippScript in CLIPP Test, simply pass a block of ClippScript in to the <code>clipp()</code> call. E.g.,</p>

<pre><code>def tc_clippscript
  clipp(consumer: 'view') do
    transaction do |t|
      t.request(raw: 'GET /foo HTTP/1.1')
    end
  end
end
</code></pre>

<p>All inputs generated by ClippScript are appended to the <code>:input_hashes</code> argument.</p>

<h1 id="helloworld">Hello World</h1>

<p>Here is a simple Hello World is ClippScript:</p>

<pre><code>connection(id: 'HelloWorld') do |c|
  c.transaction do |t|
    t.request(
      method: 'GET',
      uri: '/hello/world',
      protocol: 'HTTP/1.9',
      headers: {
        'Host' =&gt; 'Foo.Com',
        'Content-Length' =&gt; 0
      },
      body: &quot;Hello World!&quot;
    )
  end
end
</code></pre>

<p>Here is the output as Ruby Hash (<code>clippscript.rb --ruby helloworld.cs</code>):</p>

<pre><code>[{:id=&gt;&quot;HelloWorld&quot;,
  :connection=&gt;
   {:pre_transaction_event=&gt;
     [{:which=&gt;1,
       :connection_event=&gt;
        {:local_ip=&gt;&quot;1.2.3.4&quot;,
         :local_port=&gt;80,
         :remote_ip=&gt;&quot;5.6.7.8&quot;,
         :remote_port=&gt;1234}}],
    :transaction=&gt;
     [{:event=&gt;
        [{:which=&gt;5,
          :request_event=&gt;
           {:method=&gt;&quot;GET&quot;, :uri=&gt;&quot;/hello/world&quot;, :protocol=&gt;&quot;HTTP/1.9&quot;}},
         {:which=&gt;6,
          :header_event=&gt;
           {:header=&gt;
             [{:name=&gt;&quot;Host&quot;, :value=&gt;&quot;Foo.Com&quot;},
              {:name=&gt;&quot;Content-Length&quot;, :value=&gt;&quot;0&quot;}]}},
         {:which=&gt;7},
         {:which=&gt;8, :data_event=&gt;{:data=&gt;&quot;Hello World!&quot;}},
         {:which=&gt;9}]}],
    :post_transaction_event=&gt;[{:which=&gt;4}]}}]
</code></pre>

<h1 id="top-leveldirectives">Top-Level Directives</h1>

<p>ClippScript has three top-level directives of increasing specificity.</p>

<h2 id="inputoptionsdoc"><code>input(options) do |c|</code></h2>

<p><code>input</code> begins a new input (equivalent to a single connection). It provides a <code>connection</code> object with no pre-defined events.</p>

<p><strong>Options:</strong></p>

<dl>
<dt><code>id</code></dt>
<dd>The ID of the input. Defaults to &#8220;ClippScript&#8221;.</dd>
</dl>

<h2 id="connectionoptionsdoc"><code>connection(options) do |c|</code></h2>

<p><code>connection</code> begins a new input and provides a <code>connection object</code>; it automatically defines Connection Opened and Connection Closed events.</p>

<p><strong>Options:</strong></p>

<dl>
<dt><code>id</code></dt>
<dd>The ID of the input. Defaults to &#8220;ClippScript&#8221;.</dd>

<dt><code>local_ip</code></dt>
<dd>Local IP address.</dd>

<dt><code>local_port</code></dt>
<dd>Local port number.</dd>

<dt><code>remote_ip</code></dt>
<dd>Remote IP address.</dd>

<dt><code>remote_port</code></dt>
<dd>Remote port number.</dd>
</dl>

<h2 id="transactionoptionsdot"><code>transaction(options) do |t|</code></h2>

<p><code>transaction</code> begins a new input, defines Connection Opened and Connection Closed events, adds a single transaction, and provides a <code>transaction</code> object.</p>

<p><strong>Options:</strong></p>

<dl>
<dt><code>id</code></dt>
<dd>The ID of the input. Defaults to &#8220;ClippScript&#8221;.</dd>

<dt><code>local_ip</code></dt>
<dd>Local IP address.</dd>

<dt><code>local_port</code></dt>
<dd>Local port number.</dd>

<dt><code>remote_ip</code></dt>
<dd>Remote IP address.</dd>

<dt><code>remote_port</code></dt>
<dd>Remote port number.</dd>
</dl>

<h1 id="connection">Connection</h1>

<p>The top level directives <code>input</code> and <code>connection</code> both provide connection objects to their blocks. The connection object can be used to define transactions with <code>c.transaction</code> and connection level events.</p>

<h2 id="c.transactiondot"><code>c.transaction do |t|</code></h2>

<p>Begins a transaction and provides a <code>transaction</code> object.</p>

<h2 id="c.connection_openedoptions"><code>c.connection_opened(options)</code></h2>

<p>Adds a Connection Opened pre-event. Will raise an error if any pre-events already exist.</p>

<p><strong>Options:</strong></p>

<dl>
<dt><code>local_ip</code></dt>
<dd>Local IP address.</dd>

<dt><code>local_port</code></dt>
<dd>Local port number.</dd>

<dt><code>remote_ip</code></dt>
<dd>Remote IP address.</dd>

<dt><code>remote_port</code></dt>
<dd>Remote port number.</dd>

<dt><code>pre_delay</code></dt>
<dd>How long in seconds to delay before event. Can be floating point.</dd>

<dt><code>post_delay</code></dt>
<dd>How long in seconds to delay before event. Can be floating point.</dd>
</dl>

<h2 id="c.connection_closedoptions"><code>c.connection_closed(options)</code></h2>

<p>Adds a Connection Closed post-event. Will raise an error if any post-events already exist.</p>

<p><strong>Options:</strong></p>

<dl>
<dt><code>pre_delay</code></dt>
<dd>How long in seconds to delay before event. Can be floating point.</dd>

<dt><code>post_delay</code></dt>
<dd>How long in seconds to delay before event. Can be floating point.</dd>
</dl>

<h2 id="c.pre_eventwhichoptions"><code>c.pre_event(which, options)</code></h2>

<p>Adds a pre-event. See Event Methods below.</p>

<h2 id="c.post_eventwhichoptions"><code>c.post_event(which, options)</code></h2>

<p>Adds a post-event. See Event Methods below.</p>

<h1 id="transaction">Transaction</h1>

<p>The <code>c.transaction</code> method provides a transaction object to its block. The transaction object can be used to define transaction events, either directly or via a variety of helper routines.</p>

<p>There are three levels of helper routines:</p>

<ul>
<li>The highest level are <code>t.request</code> and <code>t.response</code> which define an entire requests and response, respectively. Each generates all the events necessary for an entire request/response. However, these do not allow for splitting headers or data across multiple events or for delaying events.</li>
<li>The next level has a method for each event and two helper routines: <code>t.headers</code> and <code>t.body</code> which provide some basic sanity checking, auto event typing, and a simpler interface.</li>
<li>At the lowest level is <code>t.event</code>.</li>
</ul>

<h2 id="t.requestoptions"><code>t.request(options)</code></h2>

<p>Adds events for an entire request including Request Started, Request Header, Request Header Finished, Request Body, and Request Finished. All heads will be in a single request header event and the body will be in a single Request Body event.</p>

<p><strong>Options:</strong></p>

<dl>
<dt><code>headers</code></dt>
<dd>Hash of header name to value of all request headers.</dd>

<dt><code>body</code></dt>
<dd>String of body data.</dd>

<dt><code>raw</code></dt>
<dd>The entire request line.</dd>

<dt><code>method</code>, <code>uri</code>, <code>protocol</code></dt>
<dd>The components of the request line.</dd>
</dl>

<h2 id="t.responseoptions"><code>t.response(options)</code></h2>

<p>As <code>t.request</code>, but generates events for a response instead.</p>

<p><strong>Options:</strong></p>

<dl>
<dt><code>headers</code></dt>
<dd>Hash of header name to value of all response headers.</dd>

<dt><code>body</code></dt>
<dd>String of body data.</dd>

<dt><code>raw</code></dt>
<dd>The entire response line.</dd>

<dt><code>protocol</code>, <code>status</code>, <code>message</code></dt>
<dd>The components of the response line.</dd>
</dl>

<h2 id="t.headersheaders"><code>t.headers(headers)</code></h2>

<p>Adds a Request/Response Header event and a Request/Response Header Finished event. The <code>headers</code> parameter should be a hash of header name to value. Must come immediately after a Request Started or Response Started event. To split headers across events or to add delays, use <code>t.request_header</code> or <code>t.response_header</code>.</p>

<h2 id="t.bodybody"><code>t.body(body)</code></h2>

<p>Adds a Request/Response Body event. The <code>body</code> parameter should be a string of body data. Must come immediately after either a Request/Response Started event or a Request/Response Header Finished event. To split body data across events or to add delays, use <code>t.request_body</code> or <code>t.response_body</code>.</p>

<h2 id="t.request_startedoptions"><code>t.request_started(options)</code></h2>

<p>Generate a Request Started event.</p>

<p><strong>Options:</strong></p>

<dl>
<dt><code>raw</code></dt>
<dd>The entire request line.</dd>

<dt><code>method</code>, <code>uri</code>, <code>protocol</code></dt>
<dd>The components of the request line.</dd>

<dt><code>pre_delay</code></dt>
<dd>How long in seconds to delay before event. Can be floating point.</dd>

<dt><code>post_delay</code></dt>
<dd>How long in seconds to delay before event. Can be floating point.</dd>
</dl>

<h2 id="t.response_startedoptions"><code>t.response_started(options)</code></h2>

<p>Generate a Response Started event.</p>

<p><strong>Options:</strong></p>

<dl>
<dt><code>raw</code></dt>
<dd>The entire response line.</dd>

<dt><code>protocol</code>, <code>status</code>, <code>message</code></dt>
<dd>The components of the response line.</dd>

<dt><code>pre_delay</code></dt>
<dd>How long in seconds to delay before event. Can be floating point.</dd>

<dt><code>post_delay</code></dt>
<dd>How long in seconds to delay before event. Can be floating point.</dd>
</dl>

<h2 id="t.request_headeroptions"><code>t.request_header(options)</code></h2>

<p>Generate a Request Header event.</p>

<p><strong>Options:</strong></p>

<dl>
<dt><code>headers</code></dt>
<dd>Hash of header name to value.</dd>

<dt><code>pre_delay</code></dt>
<dd>How long in seconds to delay before event. Can be floating point.</dd>

<dt><code>post_delay</code></dt>
<dd>How long in seconds to delay before event. Can be floating point.</dd>
</dl>

<h2 id="t.response_headeroptions"><code>t.response_header(options)</code></h2>

<p>Generate a Response Header event.</p>

<p><strong>Options:</strong></p>

<dl>
<dt><code>headers</code></dt>
<dd>Hash of header name to value.</dd>

<dt><code>pre_delay</code></dt>
<dd>How long in seconds to delay before event. Can be floating point.</dd>

<dt><code>post_delay</code></dt>
<dd>How long in seconds to delay before event. Can be floating point.</dd>
</dl>

<h2 id="t.request_header_finishedoptions"><code>t.request_header_finished(options)</code></h2>

<p>Generate a Request Header Finished event.</p>

<p><strong>Options:</strong></p>

<dl>
<dt><code>pre_delay</code></dt>
<dd>How long in seconds to delay before event. Can be floating point.</dd>

<dt><code>post_delay</code></dt>
<dd>How long in seconds to delay before event. Can be floating point.</dd>
</dl>

<h2 id="t.response_header_finishedoptions"><code>t.response_header_finished(options)</code></h2>

<p>Generate a Response Header Finished event.</p>

<p><strong>Options:</strong></p>

<dl>
<dt><code>pre_delay</code></dt>
<dd>How long in seconds to delay before event. Can be floating point.</dd>

<dt><code>post_delay</code></dt>
<dd>How long in seconds to delay before event. Can be floating point.</dd>
</dl>

<h2 id="t.request_bodyoptions"><code>t.request_body(options)</code></h2>

<p>Generate a Request Body event.</p>

<p><strong>Options:</strong></p>

<dl>
<dt><code>data</code></dt>
<dd>Body data.</dd>

<dt><code>pre_delay</code></dt>
<dd>How long in seconds to delay before event. Can be floating point.</dd>

<dt><code>post_delay</code></dt>
<dd>How long in seconds to delay before event. Can be floating point.</dd>
</dl>

<h2 id="t.response_bodyoptions"><code>t.response_body(options)</code></h2>

<p>Generate a Response Body event.</p>

<p><strong>Options:</strong></p>

<dl>
<dt><code>data</code></dt>
<dd>Body data.</dd>

<dt><code>pre_delay</code></dt>
<dd>How long in seconds to delay before event. Can be floating point.</dd>

<dt><code>post_delay</code></dt>
<dd>How long in seconds to delay before event. Can be floating point.</dd>
</dl>

<h2 id="t.request_finishedoptions"><code>t.request_finished(options)</code></h2>

<p>Generate a Request Finished event.</p>

<p><strong>Options:</strong></p>

<dl>
<dt><code>pre_delay</code></dt>
<dd>How long in seconds to delay before event. Can be floating point.</dd>

<dt><code>post_delay</code></dt>
<dd>How long in seconds to delay before event. Can be floating point.</dd>
</dl>

<h2 id="t.response_finishedoptions"><code>t.response_finished(options)</code></h2>

<p>Generate a Response Finished event.</p>

<p><strong>Options:</strong></p>

<dl>
<dt><code>pre_delay</code></dt>
<dd>How long in seconds to delay before event. Can be floating point.</dd>

<dt><code>post_delay</code></dt>
<dd>How long in seconds to delay before event. Can be floating point.</dd>
</dl>

<h2 id="t.connection_data_inoptions"><code>t.connection_data_in(options)</code></h2>

<p>Generate a Connection Data In event.</p>

<p><strong>Options:</strong></p>

<dl>
<dt><code>data</code></dt>
<dd>Connection data.</dd>

<dt><code>pre_delay</code></dt>
<dd>How long in seconds to delay before event. Can be floating point.</dd>

<dt><code>post_delay</code></dt>
<dd>How long in seconds to delay before event. Can be floating point.</dd>
</dl>

<h2 id="t.connection_data_outoptions"><code>t.connection_data_out(options)</code></h2>

<p>Generate a Connection Data Out event.</p>

<p><strong>Options:</strong></p>

<dl>
<dt><code>data</code></dt>
<dd>Connection data.</dd>

<dt><code>pre_delay</code></dt>
<dd>How long in seconds to delay before event. Can be floating point.</dd>

<dt><code>post_delay</code></dt>
<dd>How long in seconds to delay before event. Can be floating point.</dd>
</dl>

<h2 id="t.eventwhichoptions"><code>t.event(which, options)</code></h2>

<p>Adds an event. See Event Methods below.</p>

<h1 id="eventmethods">Event Methods</h1>

<p>There are three event methods, providing low level access to event generation &#8211; <code>c.pre_event</code>, <code>c.post_event</code>, and <code>t.event</code> &#8211; which adds pre-transaction events, post-transaction events, and transaction events, respectively. All take a <code>which</code> parameter and a set of <code>options</code>. The <code>which</code> parameter is the numeric identifier of the event type. ClippScript defines constants for all event types:</p>

<pre><code>CONNECTION_OPENED        = 1
CONNECTION_DATA_IN       = 2
CONNECTION_DATA_OUT      = 3
CONNECTION_CLOSED        = 4
REQUEST_STARTED          = 5
REQUEST_HEADER           = 6
REQUEST_HEADER_FINISHED  = 7
REQUEST_BODY             = 8
REQUEST_FINISHED         = 9
RESPONSE_STARTED         = 10
RESPONSE_HEADER          = 11
RESPONSE_HEADER_FINISHED = 12
RESPONSE_BODY            = 13
RESPONSE_FINISHED        = 14
</code></pre>

<p>The <code>options</code> parameter is a hash of options. The options <code>pre_delay</code> and <code>post_delay</code> are interpreted appropriately. All other options are placed directly as event data. For what these are and their meanings, see <code>clipp.proto</code>.</p>

<h1 id="clippscriptapi">ClippScript API</h1>

<p>ClippScript can be loaded and used as a module, <code>ClippScript</code>. The module can be included to define the top-level directives: <code>input</code>, <code>connection</code>, and <code>transaction</code>. There are three other ways of using it:</p>

<h2 id="clippscript::evalwhatdoinput"><code>ClippScript::eval(what) do |input|</code></h2>

<p>The <code>what</code> parameter must be a string of ClippScript text, or a Proc of ClippScript. In either case, it evaluates <code>what</code> and calls the block with each input as a Ruby Hash.</p>

<p>Returns nil.</p>

<h2 id="clippscript::evalwhat"><code>ClippScript::eval(what)</code></h2>

<p>As above, but returns the inputs as an array of Ruby Hashes.</p>

<h2 id="clippscript::environment.newdoinput"><code>ClippScript::Environment.new do |input|</code></h2>

<p>The resulting class defines the top-level directives and calls the block passed to the initializer for each input defined using them. It also defines <code>#get_binding</code> which returns a binding with <code>self</code> set to it, i.e., one suitable for use with <code>Kernel::eval</code>.</p>

</body>
</html>
