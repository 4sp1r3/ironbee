<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xmlns="http://docbook.org/ns/docbook"
    xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:svg="http://www.w3.org/2000/svg" xmlns:m="http://www.w3.org/1998/Math/MathML"
    xmlns:html="http://www.w3.org/1999/xhtml" xml:id="extending-ironbee">
    <title>Extending IronBee</title>
    <para>...</para>
    <section>
        <title>Overview</title>
        <para>...<warning>
                <para>This documentation is currently out of date.</para>
            </warning></para>
    </section>
    <section>
        <title>Execution Flow</title>
        <section>
            <title>Definitions</title>
            <variablelist>
                <varlistentry>
                    <term>Engine</term>
                    <listitem>
                        <para>The framework that controls data flow, state and code
                            execution.</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Plugin</term>
                    <listitem>
                        <para>Server native code for embedding the engine into another software base
                            (e.g. the Apache httpd server). The plugin is responsible for
                            instantiating the engine, initiating the initial configuration process,
                            feeding the engine with data and optionally implementing methods of
                            blocking.</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Hook</term>
                    <listitem>
                        <para>A hook is an execution point within the engine that allows external
                            code to be registered and executed as if it were part of the engine.
                            There are many builtin hooks in the IronBee engine and custom hooks can
                            also be added. Hooks are typically leveraged by modules.</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Module</term>
                    <listitem>
                        <para>Engine code that is not essential to the core engine, but rather
                            extends what the engine can accomplish by hooking into it. Modules in
                            IronBee are dynamically loadable files which can extend and alter how
                            the engine executes. There are a number of different types of modules
                            which will be explained in detail. Some examples of modules are HTTP
                            parsers, matching algorithms, logging methods, rule languages/executors
                            and specialized detection techniques. All IronBee features are
                            essentially modules, which allows nearly every aspect of the engine to
                            be extended.</para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <variablelist>
                <varlistentry>
                    <term>Provider Definition</term>
                    <listitem>
                        <para>An abstract interface, optionally defining an API, which can be used
                            to extend functionality of the engine. There are a number of providers
                            defined by the core module for parsing, logging, data manipulation,
                            matching, etc. Each definition includes a unique type, which must be
                            implemented by a provider. The provider definition essentially describes
                            the methods that must be implemented to extend the engine with the given
                            type of functionality.</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Provider</term>
                    <listitem>
                        <para>Code (normally a module) implementing an abstract interface described
                            by the provider definition. This code is then registered with the
                            provider definition type and a unique key for later lookup. For example,
                            the core module defines a provider of type "matcher" which must have a
                            set of methods implemented. The "pcre" module implements these methods
                            and registers a PCRE matcher, which can then be used by other modules to
                            perform PCRE based matches.</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Provider Instance</term>
                    <listitem>
                        <para>Some providers may require multiple instances to be instantiated with
                            differing scope or configurations. A provider instance is such an
                            instantiation, which is associated with both a provider and a
                            configuration. As an example, the data provider must manage data in
                            various scopes (e.g. connection data, session data and transaction
                            data). The core module creates a provider instance handling this data
                            for each of the different scopes. Another example is the logger provider
                            which must allow the same file based logger (a provider) to be
                            configured differently per configuration context (e.g. log to different
                            log files). </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </section>
        <section>
            <title><?oxy_comment_start author="brectanus" timestamp="20110128T233116-0800" comment="This section needs to be updated as it is a bit outdated."?>Flow<?oxy_comment_end?></title>
            <para>There are four main stages of execution detailed below.</para>
            <section>
                <title>Startup Stage</title>
                <para>During startup, the plugin is instantiated by whatever server has loaded it,
                    for example when the Apache httpd server loads/configures the plugin. During
                    this stage, the plugin instantiates the engine and initiates the configuration stage.<orderedlist>
                        <listitem>
                            <para>Server starts and instantiates/starts the plugin.</para>
                        </listitem>
                        <listitem>
                            <para>Plugin is configured with native plugin configuration, which
                                includes the location of the engine configuration.</para>
                        </listitem>
                        <listitem>
                            <para>Utility libraries are initialized.</para>
                        </listitem>
                        <listitem>
                            <para>Engine is instantiated.</para>
                            <orderedlist>
                                <listitem>
                                    <para>An engine configuration context is created.</para>
                                </listitem>
                                <listitem>
                                    <para>Static core module is loaded which defines builtin
                                        provider APIs.</para>
                                </listitem>
                            </orderedlist>
                        </listitem>
                        <listitem>
                            <para>Plugin registers a native logging provider.</para>
                        </listitem>
                        <listitem>
                            <para>Engine configuration stage is initiated based on initial plugin
                                configuration.</para>
                        </listitem>
                    </orderedlist></para>
            </section>
            <section>
                <title>Configuration Stage</title>
                <para>During configuration, the configuration files/scripts are read/executed,
                    engine modules are loaded/initialized and contexts are created/configured in
                    preparation for the runtime stage. The following is an outline of what will
                    happen during this stage.</para>
                <orderedlist>
                    <listitem>
                        <para>Configuration is read/executed.</para>
                    </listitem>
                    <listitem>
                        <para>The main configuration context is created.</para>
                    </listitem>
                    <listitem>
                        <para>Modules are loaded.<orderedlist>
                                <listitem>
                                    <para>Module global configuration data is copied to the global
                                        context as a base configuration.</para>
                                </listitem>
                                <listitem>
                                    <para>Module "init" function is called just after it is loaded
                                        to initialize any global module configuration.</para>
                                </listitem>
                                <listitem>
                                    <para>Modules may hook into the engine globally by registering
                                        to be called when certain events occur.</para>
                                </listitem>
                                <listitem>
                                    <para>If successfully initialized, a module is registered with
                                        the engine.</para>
                                </listitem>
                            </orderedlist></para>
                    </listitem>
                    <listitem>
                        <para>Configuration contexts are created and registered along with a
                            function which will be executed to determine if the context will be
                            chosen at runtime.</para>
                    </listitem>
                    <listitem>
                        <para>Modules register themselves with a configuration context if they are
                            to be used in that context.</para>
                        <orderedlist>
                            <listitem>
                                <para>Module "context init" function is called to initialize any
                                    context configuration.</para>
                            </listitem>
                            <listitem>
                                <para>Modules may hook into the engine for the given context by
                                    registering to be called when certain events occur.</para>
                            </listitem>
                        </orderedlist>
                    </listitem>
                    <listitem>
                        <para>The runtime stage is initiated.</para>
                    </listitem>
                </orderedlist>
                <section>
                    <title>Runtime Stage</title>
                    <para>During runtime all of the configuration has been finalized and the engine
                        will now handle data passed to it by the plugin. Data is handled by the
                        state machine which essentially follows a four step process. First, a
                        configuration context is chosen. Second, the request is handled. Third the
                        response is handled. And finally any post processing is performed. Below is
                        an outline of the flow.</para>
                    <orderedlist>
                        <listitem>
                            <para>Raw connection HTTP data is received by the plugin and passed to
                                the engine.</para>
                        </listitem>
                        <listitem>
                            <para>[Need to add connection context here. Events could be: conn open,
                                conn data (inbound/outbound), conn close. Configuration options
                                include which protocol parser to use, default parser configuration,
                                whether to decrypt SSL, private keys for decryption, etc.]</para>
                        </listitem>
                        <listitem>
                            <para>If the connection is encrypted, SSL decryption takes place. This
                                step is optional and will largely depend on how the plugin is
                                designed. For example, the Apache plugin will always send decrypted
                                data.</para>
                        </listitem>
                        <listitem>
                            <para>The engine parses the data as a stream, buffering if configured to
                                do so.</para>
                        </listitem>
                        <listitem>
                            <para>The parser notifies the engine of various events (request headers
                                available, request body, etc.)</para>
                        </listitem>
                        <listitem>
                            <para>Any hooks associated with events are executed.</para>
                        </listitem>
                        <listitem>
                            <para>Once enough data is available, the configuration context selection
                                process is started configuration context function until one returns
                                that it wants to be enabled.</para>
                            <orderedlist>
                                <listitem>
                                    <para>At this point all modules registered in the chosen context
                                        will have their "context activated" functions executed,
                                        allowing them to be prepared for executing in the
                                        context.</para>
                                </listitem>
                            </orderedlist>
                        </listitem>
                        <listitem>
                            <para>Further events occur and associated hooks are executed, but now
                                with the chosen configuration context instead of the global
                                context.</para>
                        </listitem>
                    </orderedlist>
                </section>
                <section>
                    <title>Reconfiguration Stage</title>
                    <para>During a reconfiguration, the engine has been notified that configuration
                        changes are available and should be reloaded. This is very similar to
                        startup, except that instead of the plugin initiating the configuration
                        stage, the engine is initiating the configuration stage. During this time
                        and current data being processed will continue to use the old
                        configuration.</para>
                    <para> TODO</para>
                </section>
            </section>
        </section>
    </section>
    <section>
        <title>Hooks</title>
        <para>TODO: Add description of each hook</para>
    </section>
    <section>
        <title>Modules</title>
        <para>Modules make up the majority of executed code in IronBee. Most features are built
            using modules. There are three primary reasons for this. First, it makes the code more
            readable and each feature more self contained. Second, it allows only features in use to
            be loaded into the executable. And last, since modules are shared libraries, it makes
            for easier upgrades as the engine only needs to unload the old code and reload the
            new.</para>
        <para>Modules can interact with the engine in quite a few different ways. However, there are
            two primary module types: provider and standalone. The simplest is the provider module,
            which implements one of the many predefined (or even custom) provider definitions. As an
            example, a provider module can be used to extend logging capabilities, add a different
            type of pattern matcher or provide a different way of storing/accessing data. The
            provider module typically will define a configuration and set of functions implementing
            a provider's well defined interface, then register these functions with the engine. A
            standalone module will typically be more involved. Standalone modules can hook into any
            part of the engine and typically used to implement a new detection technique or provide
            some sort of filtering. To do this, the standalone module defines a configuration and
            registers functions with various hooks in the engine. While this is similar to a
            provider module, there is no well defined set of functions to implement in a standalone
            module.</para>
        <section>
            <title>Standalone Modules</title>
            <para>Modules have three essential duties. A module must export a known symbol so that
                it can be loaded. A set of configuration parameters may be set. And common module
                functions must be registered which will be called at various initialization and
                cleanup points. With Lua, however, this is much more simplified than in C.</para>
            <para>Exporting a symbol is quite language specific and will not be discussed
                here.</para>
            <para>Any number of configuration parameters are registered with the engine and their
                storage locations are then mapped by the engine both globally to the module as well
                as into each configuration context. As of this writing, there are two types of
                configuration parameters, numeric and string. Along with configuration parameter
                definitions can be defined default values.</para>
            <para>The eventual goal of a module is to register functions to be called by the engine.
                Typically in  a standalone module, this is done by registering functions to be
                called with hooks. Hooks allow executing at defined points in the
                connection/transaction lifecycle, which is documented with the state machine in the
                API documentation.</para>
            <para>TODO: Need more on what a basic module will look like without going into language
                details.</para>
        </section>
        <section>
            <title>Provider Modules</title>
            <para>A provider module typically implements the core provider APIs -- allowing
                different methods of debug logging, matching, etc. -- but a provider module can also
                extend the core by adding its own custom interface. Providers are defined with a set
                of module configuration parameters, an API to allow calling the provider and an
                abstract interface which must be implemented by other modules. This abstract
                interface is what most provider modules will be implementing.</para>
            <para>The <literal>provider API</literal> is the interface in which the consumer will
                call to use the service. This is essentially the public calling interface. Typically
                this is already defined by the core provider definitions and is only used to define
                custom providers. As an example, the core logger API defines two functions to
                perform logging. The first is a vprintf like function with a va_list argument and
                the second a printf like function with a variable argument list.</para>
            <para>The <literal>provider interface</literal> is what is called by the API to do the
                real work. This is a private interface in which any module implementing this
                provider will need to implement. In the case of the logger provider, there is a
                single function named "logger" of type "qi_log_logger_fn_t". Both of the functions
                defined in the API will just call this function to do the actual logging. Note, as
                in this case, the public API does not have to match the private interface.</para>
            <para>To implement a defined provider interface, a module needs to register any required
                interface functions with the engine with a unique key. At this point the provider's
                register function is called. This function is defined with the provider and is
                typically used to validate the registered interface, allowing version checking as
                well as any initial setup (the "version" field is defined by the default interface
                header).</para>
            <para/>
            <section>
                <title>Core Provider Interfaces</title>
                <para>The engine core defines a number of standard provider interfaces which a
                    module can implement. Each interface is implemented using the same concepts as
                    above, however each has a different API.</para>
                <section>
                    <title>Logging Interface</title>
                    <para>...</para>
                    
                </section>
                <section>
                    <title>Event Interface</title>
                    <para>...</para>
                </section>
                <section>
                    <title>HTTP Parser Interface</title>
                    <para>...</para>
                </section>
                <section>
                    <title>Matcher Interface</title>
                    <para>...</para>
                </section>
                <section>
                    <title>Data Interface</title>
                    <para>...</para>
                </section>
            </section>
        </section>
    </section>
    <section>
        <title>Writing Modules in C</title>
        <para>TODO: Some general description on why one would want to do this.</para>
        <section>
            <title>Anatomy of a C Module</title>
            <para>A C module is built into a shared library. The shared library exposes a known
                structure (see <xref linkend="ex.module-struct-definition"/>) that IronBee uses to load the module.</para>
            <example xml:id="ex.module-struct-definition">
                <title>IronBee Module Structure</title>
                <programlisting><xi:include href="extending-ironbee/module-struct-definition.txt" parse="text"/></programlisting>
            </example>
            <para>A module must define and initialize this structure to be loadable in IronBee. This
                is done by defining a few functions and making a few macro calls. A minimal module
                example is given in <xref linkend="ex.minimal-module"/>.</para>
            <example xml:id="ex.minimal-module">
                <title>Minimal Module</title>
                <programlisting><xi:include href="extending-ironbee/minimal-module.txt" parse="text"/></programlisting>
            </example>
            <para><xref linkend="ex.minimal-module"/> shows a very minimalistic module that does
                nothing but log when the module loads and unloads. The module includes some standard
                IronBee headers, declares itself a module and defines two functions. The module
                structure is then initialized with these functions assigned to the
                    <literal>fn_init</literal> and <literal>fn_fini</literal> fields. This results
                in the <literal>exmin_init</literal> and <literal>exmin_fini</literal> functions
                being called when the module is loaded and unloaded, respectfully. Of course much
                more can be done with a module.</para>
            <para>TODO: Describe what other things a module can do.</para>            
        </section>
        <section>
            <title>A Simple C Module Example</title>
            <para>To better illustrate writing a C module we need a simple task to accomplish. Here
                we will define a minimalistic signature language. To keep things simple, the module
                will stick to IronBee built-in features and ignore any performance concerns. The
                module will simply allow a user to add signature to IronBee. In this case a
                signature is defined as performing a PCRE based regular expression on a given data
                field and triggering an event if there is a match.</para>
            <para>To accomplish this task, we need to write a module that does the following:<itemizedlist>
                    <listitem>
                        <para>Allow writing a signature within the configuration file that allows
                            specifying when it should execute, what field it should match against, a
                            regular expression and an event message that should be triggered on
                            match.</para>
                    </listitem>
                    <listitem>
                        <para>Parse the signature into its various components.</para>
                    </listitem>
                    <listitem>
                        <para>Compile the PCRE and store the signature for later execution.</para>
                    </listitem>
                    <listitem>
                        <para>At runtime, execute the signatures at the specified time.</para>
                    </listitem>
                    <listitem>
                        <para>If a signature matches, generate an event.</para>
                    </listitem>
                </itemizedlist></para>
            <para>The module begins the same as in <xref linkend="ex.minimal-module"/>, but with
                some additional type definitions which we will use to store our signatures.</para>
            <example>
                <title>Signature Module Setup</title>
                <programlisting><xi:include parse="text" href="extending-ironbee/pocsig-setup.txt"/></programlisting>
            </example>
            <section>
                <title>Configuration</title>
                <para>Modules control their own configuration structure. Normally a module will use
                    a simple C structure which it can reference directly. However, a module may also
                    expose some or all of its configuration. Any exposed parameters can then be
                    accessed by other modules and/or through the configuration language. In addition
                    to exposing configuration parameters a module can register and expose new
                    configuration directives for use in the configuration language.</para>
                <para>In this example we will need to track multiple lists of signatures (one for
                    each point of execution) and a handle to the PCRE pattern matcher. While these
                    will not be exposed, we will expose a numeric parameter to toggle tracing
                    signature execution. The configuration is defined and instantiated in a C
                    structure shown in <xref linkend="ex.config-structure"/>.</para>
                <example xml:id="ex.config-structure">
                    <title>Configuration Structure</title>
                    <programlisting><xi:include parse="text" href="extending-ironbee/pocsig-config.txt"/></programlisting>
                </example>
                <para>We will then define a configuration directive to control tracing as well as
                    signature directives for each phase of execution. Note that multiple signature
                    directives are only used to simplify the example so that we do not have to write
                    rule parsing code. The functions defined in <xref
                        linkend="ex.pocsig-dirhandlers"/> are used to handle the configuration
                    directives, which we will define later on.</para>
                <para>The <literal>pocsig_dir_trace</literal> function is a simple single parameter
                    directive handler which parses the parameter for a "On" or "Off" value and sets
                    a numeric parameter value in the configuration context. We will see how this
                    parameter is exposed later on. The <literal>pocsig_dir_signature</literal>
                    function is a directive handler that can handle an arbitrary number of
                    parameters. Note that much of this function is described later on with pattern
                    matchers.</para>
                <example xml:id="ex.pocsig-dirhandlers">
                    <title>Configuration Directive Handlers</title>
                    <programlisting><xi:include parse="text" href="extending-ironbee/pocsig-dirhandlers.txt"/></programlisting>
                </example>
                <para>Any configuration parameters and directives must be registered with the
                    engine. This is accomplished through two mapping structures as shown in <xref
                        linkend="ex.pocsig-regconfig"/>. The exposed configuration parameter is
                    named, typically modulename.name, and the engine told it type, offset, length
                    and default value.  This is wrapped into a macro to make this much easier. The
                    configuration directives are registered in a similar fashion and mapped to
                    handler functions.</para>
                <example xml:id="ex.pocsig-regconfig">
                    <title>Registering the Configuration</title>
                    <programlisting><xi:include parse="text" href="extending-ironbee/pocsig-regconfig.txt"/></programlisting>
                </example>
            </section>
            <section>
                <title>Pattern Matchers</title>
                <para>Pattern matchers are defined through the matcher provider interface. These
                    matchers are typically loaded via modules. In case of the PCRE matcher, it is
                    loaded through the pcre module, which must be loaded for our example module to
                    work. A matcher provider exposes a common interface for calling any pattern
                    matchers registered with the engine.</para>
                <para>In <xref linkend="ex.pocsig-dirhandlers"/>
                    <literal>ib_matcher_create</literal> is used to fetch the PCRE pattern matcher.
                    This matcher is used here to compile the patterns with ib_matcher_compile. The
                    matcher is stored in the configuration context for later use in executing the
                    signatures. The compiled pattern is stored in the signature structure which is
                    added to a list for later execution.</para>
            </section>
            <section>
                <title>Hooks</title>
                <para>Up until now, we have been dealing with configuration time processing. In
                    order to handle processing at runtime, we have to define a handler and register
                    this handler to be executed at defined points. Since all signatures are executed
                    in the same fashion, we can define a single handler and register it to be
                    executed multiple times.</para>
                <example xml:id="ex.pocsig-hooks">
                    <title>Runtime Hook Handlers</title>
                    <programlisting><xi:include parse="text" href="extending-ironbee/pocsig-hooks.txt"/></programlisting>
                </example>
                <para><xref linkend="ex.pocsig-hooks"/> defines a handler for executing our
                    signatures at runtime. In order to use this handler with each phase, we will
                    pass the phase number to the handler. Other than some casting trickery to pass
                    the phase number, the function is fairly straight forward. It loops through a
                    phase list, fetches the data field it will match against, matches the
                    pre-compiled pattern against the field and then logs an event if there is a
                    match.</para>
                <para>All that is left in the module is to register the signature handler to be
                    executed in the various phases. <xref linkend="ex.pocsig-module"/> shows the
                    finial module functions and registration required for this. Normally
                    configuration data is exposed publicly where it is given a default value. Since
                    some of our configuration is not exposed, we  need to initialize the data
                    ourselves. This is done though the module initialization function,
                        <literal>pocsig_init</literal>. The context initialization function,
                        <literal>pocsig_context_init</literal>, is called for each configuration
                    context that this module is configured. This is where we register our handler
                    with the engine hooks and define the phase numbers that are passed to the
                    handler. Finally, the module structure is initialized to point to the various
                    configuration mapping structures and module initialization functions.</para>
                <example xml:id="ex.pocsig-module">
                    <title>Module Functions and Registration</title>
                    <programlisting><xi:include parse="text" href="extending-ironbee/pocsig-module.txt"/></programlisting>
                </example>
            </section>
            <section>
                <title>Events</title>
                <para>TODO</para>
            </section>
        </section>
    </section>
    <section>
        <title>Writing Modules in Lua</title>
        <para>Lua modules are designed to be much easier to develop than a C equivalent. A Lua
            IronBee module is built like any other Lua module. Really all you need to do is to
            implement handlers which are executed when an event is triggered. These event handlers
            (prefixed with "onEvent") are automatically registered with the engine on load. Simply
            put the code you want executed in the appropriate handler and that is about it.</para>
        <programlisting><![CDATA[-- ===============================================
-- Define local aliases of any globals to be used.
-- ===============================================
local base = _G
local ironbee = require("ironbee-ffi")

-- ===============================================
-- Declare the rest of the file as a module and
-- register the module table with ironbee.
-- ===============================================
module(...)
_COPYRIGHT = "Copyright (C) 2010-2011 Qualys, Inc."
_DESCRIPTION = "IronBee example Lua module"
_VERSION = "0.1"

-- ===============================================
-- This is called to handle the
-- LuaExampleDirective directive.
--
-- ib: IronBee engine handle
-- cbdata: Callback data (from registration)
-- ...: Any arguments
-- ===============================================
function onDirectiveLuaExampleDirective(ib, cbdata, ...)
    ironbee.ib_log_debug(ib, 4, "%s.onDirectiveLuaExampleDirective ib=%p",
                       _NAME, ib.cvalue())
    return 0
end

-- ===============================================
-- This is called when the module loads
--
-- ib: IronBee engine handle
-- ===============================================
function onModuleLoad(ib)
    ironbee.ib_log_debug(ib, 4, "%s.onModuleLoad ib=%p",
                       _NAME, ib.cvalue())

    -- Register to handle a configuration directive
    ironbee.ib_config_register_directive(
        -- Engine handle
        ib,
        -- Directive
        "LuaExampleDirective",
        -- Directive Type (currently it MUST be 0 for directive or 1 for block)
        0,
        -- Full name of handler: modulename.funcname
        _NAME .. ".onDirectiveLuaExampleDirective",
        -- Block end function
        nil,
        -- Callback data (should be number, string or other C compat type)
        nil
    )

    return 0
end

-- ===============================================
-- ===============================================
-- Event Handlers
--
-- Normally only the onEventHandle* functions are
-- used for detection, but they are all listed
-- here.
--
-- NOTE: As a best practice, you should avoid
-- using the "onEvent" prefix in any public
-- functions that are NOT to be used as event
-- handlers as these may be treated specially
-- by the engine.
-- ===============================================
-- ===============================================

-- ===============================================
-- This is called when a connection context was
-- chosen and is ready to be handled.
--
-- ib: IronBee engine handle
-- conn: IronBee connection handle
-- ===============================================
function onEventHandleContextConn(ib, conn)
    ironbee.ib_log_debug(ib, 4, "%s.onEventHandleContextConn ib=%p conn=%p",
                       _NAME, ib.cvalue(), conn.cvalue())

    -- Create a pcre matcher for later use
    if pcre == nil then
        pcre = ironbee.ib_matcher_create(ib, conn.mp(), "pcre")
        ironbee.ib_log_debug(ib, 4, "Created PCRE matcher=%p", pcre)
    end

    return 0
end

-- ===============================================
-- This is called when the request headers are
-- available to inspect.
--
-- ib: IronBee engine handle
-- tx: IronBee transaction handle
-- ===============================================
function onEventHandleRequestHeaders(ib, tx)
    ironbee.ib_log_debug(ib, 4, "%s.onEventHandleRequestHeaders ib=%p tx=%s",
                       _NAME, ib.cvalue(), tx.id())

    -- Request line is a scalar value (a field object type)
    local req_line = ironbee.ib_data_get(tx.dpi(), "request_line")
    ironbee.ib_log_debug(ib, 4, "Request line is a field type: %d", req_line.type())

    -- The cvalue ("C" Value) is a pointer to the field structure, which is
    -- not very useful in Lua, but shows that you do have a direct access
    -- to the "C" inner workings:
    ironbee.ib_log_debug(ib, 4, "Request Line cvalue: %p", req_line.cvalue())

    -- The value is a Lua value (string) which can be used with other
    -- Lua functions. Be aware, however, that calling value() makes a
    -- copy of the underlying "C" representation to create the Lua version
    -- and you may not want the overhead of doing thisi (see PCRE matcher
    -- below for another option).
    ironbee.ib_log_debug(ib, 4, "Request Line value: %s", req_line.value())

    -- You can also request a transformed value
    local req_line_lower = ironbee.ib_data_tfn_get(tx.dpi(), "request_line", "lowercase")
    ironbee.ib_log_debug(ib, 4, "Lower case request line is a field type: %d", req_line_lower.type())
    ironbee.ib_log_debug(ib, 4, "Lower case Request Line value: %s", req_line_lower.value())

    -- Request headers are a collection (table of field objects)
    local req_headers = ironbee.ib_data_get(tx.dpi(), "request_headers")
    ironbee.ib_log_debug(ib, 4, "Request Headers is a field type: %d", req_headers.type())
    if req_headers.type() == ironbee.IB_FTYPE_LIST then
        for k,f in base.pairs(req_headers.value()) do
            if f.type() == ironbee.IB_FTYPE_LIST then
                ironbee.ib_log_debug(ib, 4, "Request Header value: %s=<list>", k)
            else
                ironbee.ib_log_debug(ib, 4, "Request Header value: %s=%s", k, f.value())
            end
        end
    end
    -- Or you can access individual subfields within collections directly
    -- via "name.subname" syntax:
    local http_host_header = ironbee.ib_data_get(tx.dpi(), "request_headers.host")
    ironbee.ib_log_debug(ib, 4, "HTTP Host Header is a field type: %d", http_host_header.type())
    ironbee.ib_log_debug(ib, 4, "HTTP Host Header value: %s", http_host_header.value())


    -- Request URI params are a collection (table of field objects)
    local req_uri_params = ironbee.ib_data_get(tx.dpi(), "request_uri_params")
    ironbee.ib_log_debug(ib, 4, "Request URI Params is a field type: %d", req_uri_params.type())
    if req_uri_params.type() == ironbee.IB_FTYPE_LIST then
        for k,f in base.pairs(req_uri_params.value()) do
            if f.type() == ironbee.IB_FTYPE_LIST then
                ironbee.ib_log_debug(ib, 4, "Request URI Param value: %s=<list>", k)
            else
                ironbee.ib_log_debug(ib, 4, "Request URI Param value: %s=%s", k, f.value())
            end
        end
    end

    -- Use the IronBee PCRE matcher directly
    --
    -- A benefit of doing this over using any builtin Lua matchers is that
    -- a Lua copy of the value is not required. Using the PCRE matcher passes
    -- the field value by reference (the cvalue) without the overhead of
    -- a copy. You should use this method for large values.
    --
    -- NOTE: The "pcre" variable used here was initialized in the
    --       onEventHandleContextConn() handler so that it can be used
    --       in any other handler following it.
    if pcre ~= nil then
        local patt = "(?i:foo)"
        local rc = ironbee.ib_matcher_match_field(pcre, patt, 0, req_line)
        if rc == ironbee.IB_OK then
            ironbee.ib_log_debug(ib, 4, "Request Line matches: %s", patt)
            -- Generate a test event (alert)
            ironbee.ib_clog_event(
                tx.ctx(), 
                ironbee.ib_logevent_create(
                    tx.mp(),
                    "-",
                    IB_LEVENT_TYPE_ALERT,
                    IB_LEVENT_ACT_ATTEMPTED_ATTACK,
                    IB_LEVENT_PCLASS_INJECTION,
                    IB_LEVENT_SCLASS_SQL,
                    90, 80,
                    IB_LEVENT_SYS_PUBLIC,
                    IB_LEVENT_ACTION_BLOCK,
                    IB_LEVENT_ACTION_IGNORED,
                    "[TEST Event] Request Line matches: %s", patt
                )
            )
        else
            ironbee.ib_log_debug(ib, 4, "Request Line does not match: %s", patt)
        end
    end

    return 0
end]]></programlisting>
    </section>
</chapter>
