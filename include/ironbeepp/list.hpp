/*****************************************************************************
 * Licensed to Qualys, Inc. (QUALYS) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * QUALYS licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ****************************************************************************/

/**
 * @file
 * @brief IronBee++ &mdash; List
 *
 * This file defines (Const)List, a wrapper for ib_list_t.
 *
 * @remark Developers should be familiar with @ref ironbeepp to understand
 * aspects of this code, e.g., the public/non-virtual inheritance.
 *
 * @author Christopher Alfeld <calfeld@qualys.com>
 */

#ifndef __IBPP__LIST__
#define __IBPP__LIST__

#include <ironbeepp/common_semantics.hpp>
#include <ironbeepp/exception.hpp>
#include <ironbeepp/memory_pool.hpp>

#include <boost/iterator/iterator_facade.hpp>
#include <boost/utility/enable_if.hpp>
#include <boost/type_traits/is_same.hpp>
#include <boost/type_traits/is_convertible.hpp>

#include <ostream>

#include <ironbee/list.h>

namespace IronBee {

/// @cond Internal
namespace Internal {

/**
 * Iterate through an ib_list_t, casting values to pointers.
 *
 * This template implements non-mutable bidirectional iterators for ib_list_t,
 * where the values are cast to a pointer type, @a T, via reinterpret_cast
 * (contrast to list_const_iterator).
 *
 * It is generated by List and ConstList when their value type is a pointer.
 *
 * Note that the reference type for this iterator is @a T not @c const @a T&.
 *
 * @sa list_const_iterator
 * @sa List
 * @sa ConstList
 *
 * @tparam T Value to cast @c void* list value to.
 **/
template <typename T>
class pointer_list_const_iterator :
    public boost::iterator_facade<
        pointer_list_const_iterator<T>,
        T,
        boost::bidirectional_traversal_tag,
        T
    >
{
public:
    //! Construct from ib_list_node_t.
    explicit
    pointer_list_const_iterator(ib_list_node_t* node) :
        m_node(node)
    {
        init_node(m_past_the_end);
        init_node(m_before_the_beginning);
    }

    //! Default constructor; all operations except assignment undefined.
    pointer_list_const_iterator() :
        m_node(NULL)
    {
        init_node(m_past_the_end);
        init_node(m_before_the_beginning);
    }

    //! Copy constructor.
    pointer_list_const_iterator(
        const pointer_list_const_iterator& other
    )
    {
        init_node(m_past_the_end);
        init_node(m_before_the_beginning);

        if (other.m_node == &other.m_before_the_beginning) {
            m_before_the_beginning.next = other.m_before_the_beginning.next;
            m_node = &m_before_the_beginning;
        }
        else if (other.m_node == & other.m_past_the_end) {
            m_past_the_end.prev = other.m_past_the_end.prev;
            m_node = &m_past_the_end;
        } else {
            m_node = other.m_node;
        }
    }

private:
    friend class boost::iterator_core_access;

    //! Initialize @a n to all NULLs.
    static void init_node(ib_list_node_t& n)
    {
        n.next = NULL;
        n.prev = NULL;
        n.data = NULL;
    }

    //! Increment iterator.
    void increment()
    {
        if (m_node != &m_past_the_end) {
            if (m_node->next) {
                m_node = m_node->next;
            } else {
                // moving past end
                m_past_the_end.prev = m_node;
                m_node = &m_past_the_end;
            }
        }
    }

    //! Decrement iterator.
    void decrement()
    {
        if (m_node != &m_before_the_beginning) {
            if (m_node->prev) {
                m_node = m_node->prev;
            } else {
                // moving before beginning
                m_before_the_beginning.next = m_node;
                m_node = &m_before_the_beginning;
            }
        }
    }

    //! Compare iterators.
    bool equal(
        const pointer_list_const_iterator& other
    ) const
    {
        return
            (m_node == other.m_node) ||
            (
                m_node == &m_before_the_beginning &&
                other.m_node == &other.m_before_the_beginning
            ) ||
            (
                m_node == &m_past_the_end &&
                other.m_node == &other.m_past_the_end
            )
            ;
    }

    //! Dereference iterator.  Note return of copy.
    T dereference() const
    {
        return reinterpret_cast<T>(m_node->data);
    }

    ib_list_node_t  m_before_the_beginning;
    ib_list_node_t  m_past_the_end;
    ib_list_node_t* m_node;
};

/**
 * Iterate through an ib_list_t, casting values to IronBee++ objects.
 *
 * This template implements non-mutable bidirectional iterators for ib_list_t,
 * where the values are converted to IronBee++ objects.  Recall that IronBee++
 * objects behave much like pointers.
 *
 * It is generated by List and ConstList when their value type is not a
 * pointer.
 *
 * Note that the reference type for this iterator is @a T not @c const @a T&.
 *
 * @sa pointer_list_const_iterator
 * @sa List
 * @sa ConstList
 *
 * @remark This template is adapted from pointer_list_iterator<T::ib_type>.
 *
 * @tparam T Value to convert list value to.  Must define @c ib_type member
 *           typedef and a constructor from @c ib_type.
 **/
template <typename T>
class list_const_iterator :
    public boost::iterator_adaptor<
        list_const_iterator<T>,
        pointer_list_const_iterator<typename T::ib_type>,
        T,
        boost::bidirectional_traversal_tag,
        T // Note: Copy not reference.
    >
{
public:
    //! Default constructor; all operations except assignment undefined.
    list_const_iterator() :
        list_const_iterator::iterator_adaptor_(0)
    {
        // nop
    }

    //! Construct from ib_list_node_t.
    explicit
    list_const_iterator(
        ib_list_node_t* node
    )  :
        list_const_iterator::iterator_adaptor_(
            pointer_list_const_iterator<typename T::ib_type>(node)
        )
    {
        // nop
    }

    //! Copy constructor.
    list_const_iterator(
        const list_const_iterator& other
    ) :
        list_const_iterator::iterator_adaptor_(other.base())
    {
        // nop
    }

private:
    friend class boost::iterator_core_access;

    //! Operator-> support.
    T* operator->() const
    {
        static T m_dummy;
        m_dummy = T(*this->base());
        return &m_dummy;
    }

    //! Dereference.  Note returns copy not reference.
    T dereference() const
    {
        return T(*this->base());
    }
};

/**
 * Metafunction to calculate appropriate iterator type.
 *
 * If @a T is a pointer then pointer_list_const_iterator is used, otherwise
 * list_const_iterator is used.
 *
 * @tparam T Desired value type of iterator.
 **/
template <typename T>
struct make_list_const_iterator
{
    typedef list_const_iterator<T> type;
};

//! Overload of previous to make it work for pointers.
template <typename Base>
struct make_list_const_iterator<Base*>
{
    typedef pointer_list_const_iterator<Base*> type;
};

} // Internal
/// @endcond

} // IronBee

#endif